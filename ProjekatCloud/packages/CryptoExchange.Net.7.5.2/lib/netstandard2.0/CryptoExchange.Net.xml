<?xml version="1.0"?>
<doc>
    <assembly>
        <name>CryptoExchange.Net</name>
    </assembly>
    <members>
        <member name="T:CryptoExchange.Net.Attributes.JsonConversionAttribute">
            <summary>
            Used for conversion in ArrayConverter
            </summary>
        </member>
        <member name="T:CryptoExchange.Net.Attributes.MapAttribute">
            <summary>
            Map a enum entry to string values
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Attributes.MapAttribute.Values">
            <summary>
            Values mapping to the enum entry
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.Attributes.MapAttribute.#ctor(System.String[])">
            <summary>
            ctor
            </summary>
            <param name="maps"></param>
        </member>
        <member name="T:CryptoExchange.Net.Authentication.ApiCredentials">
            <summary>
            Api credentials, used to sign requests accessing private endpoints
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Authentication.ApiCredentials.Key">
            <summary>
            The api key to authenticate requests
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Authentication.ApiCredentials.Secret">
            <summary>
            The api secret to authenticate requests
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Authentication.ApiCredentials.CredentialType">
            <summary>
            Type of the credentials
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.Authentication.ApiCredentials.#ctor(System.Security.SecureString,System.Security.SecureString)">
            <summary>
            Create Api credentials providing an api key and secret for authentication
            </summary>
            <param name="key">The api key used for identification</param>
            <param name="secret">The api secret used for signing</param>
        </member>
        <member name="M:CryptoExchange.Net.Authentication.ApiCredentials.#ctor(System.Security.SecureString,System.Security.SecureString,CryptoExchange.Net.Authentication.ApiCredentialsType)">
            <summary>
            Create Api credentials providing an api key and secret for authentication
            </summary>
            <param name="key">The api key used for identification</param>
            <param name="secret">The api secret used for signing</param>
            <param name="credentialsType">The type of credentials</param>
        </member>
        <member name="M:CryptoExchange.Net.Authentication.ApiCredentials.#ctor(System.String,System.String)">
            <summary>
            Create Api credentials providing an api key and secret for authentication
            </summary>
            <param name="key">The api key used for identification</param>
            <param name="secret">The api secret used for signing</param>
        </member>
        <member name="M:CryptoExchange.Net.Authentication.ApiCredentials.#ctor(System.String,System.String,CryptoExchange.Net.Authentication.ApiCredentialsType)">
            <summary>
            Create Api credentials providing an api key and secret for authentication
            </summary>
            <param name="key">The api key used for identification</param>
            <param name="secret">The api secret used for signing</param>
            <param name="credentialsType">The type of credentials</param>
        </member>
        <member name="M:CryptoExchange.Net.Authentication.ApiCredentials.Copy">
            <summary>
            Copy the credentials
            </summary>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Authentication.ApiCredentials.#ctor(System.IO.Stream,System.String,System.String)">
            <summary>
            Create Api credentials providing a stream containing json data. The json data should include two values: apiKey and apiSecret
            </summary>
            <param name="inputStream">The stream containing the json data</param>
            <param name="identifierKey">A key to identify the credentials for the API. For example, when set to `binanceKey` the json data should contain a value for the property `binanceKey`. Defaults to 'apiKey'.</param>
            <param name="identifierSecret">A key to identify the credentials for the API. For example, when set to `binanceSecret` the json data should contain a value for the property `binanceSecret`. Defaults to 'apiSecret'.</param>
        </member>
        <member name="M:CryptoExchange.Net.Authentication.ApiCredentials.Dispose">
            <summary>
            Dispose
            </summary>
        </member>
        <member name="T:CryptoExchange.Net.Authentication.ApiCredentialsType">
            <summary>
            Credentials type
            </summary>
        </member>
        <member name="F:CryptoExchange.Net.Authentication.ApiCredentialsType.Hmac">
            <summary>
            Hmac keys credentials
            </summary>
        </member>
        <member name="F:CryptoExchange.Net.Authentication.ApiCredentialsType.RsaXml">
            <summary>
            Rsa keys credentials in xml format
            </summary>
        </member>
        <member name="F:CryptoExchange.Net.Authentication.ApiCredentialsType.RsaPem">
            <summary>
            Rsa keys credentials in pem/base64 format. Only available for .NetStandard 2.1 and up, use xml format for lower.
            </summary>
        </member>
        <member name="T:CryptoExchange.Net.Authentication.AuthenticationProvider">
            <summary>
            Base class for authentication providers
            </summary>
        </member>
        <member name="F:CryptoExchange.Net.Authentication.AuthenticationProvider._credentials">
            <summary>
            Provided credentials
            </summary>
        </member>
        <member name="F:CryptoExchange.Net.Authentication.AuthenticationProvider._sBytes">
            <summary>
            Byte representation of the secret
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.Authentication.AuthenticationProvider.#ctor(CryptoExchange.Net.Authentication.ApiCredentials)">
            <summary>
            ctor
            </summary>
            <param name="credentials"></param>
        </member>
        <member name="M:CryptoExchange.Net.Authentication.AuthenticationProvider.AuthenticateRequest(CryptoExchange.Net.Clients.RestApiClient,System.Uri,System.Net.Http.HttpMethod,System.Collections.Generic.IDictionary{System.String,System.Object},System.Collections.Generic.IDictionary{System.String,System.Object},System.Collections.Generic.Dictionary{System.String,System.String},System.Boolean,CryptoExchange.Net.Objects.ArrayParametersSerialization,CryptoExchange.Net.Objects.HttpMethodParameterPosition,CryptoExchange.Net.Objects.RequestBodyFormat)">
            <summary>
            Authenticate a request. Output parameters should include the providedParameters input
            </summary>
            <param name="apiClient">The Api client sending the request</param>
            <param name="uri">The uri for the request</param>
            <param name="method">The method of the request</param>
            <param name="auth">If the requests should be authenticated</param>
            <param name="arraySerialization">Array serialization type</param>
            <param name="parameterPosition">The position where the providedParameters should go</param>
            <param name="requestBodyFormat">The formatting of the request body</param>
            <param name="uriParameters">Parameters that need to be in the Uri of the request. Should include the provided parameters if they should go in the uri</param>
            <param name="bodyParameters">Parameters that need to be in the body of the request. Should include the provided parameters if they should go in the body</param>
            <param name="headers">The headers that should be send with the request</param>
        </member>
        <member name="M:CryptoExchange.Net.Authentication.AuthenticationProvider.SignSHA256Bytes(System.String)">
            <summary>
            SHA256 sign the data and return the bytes
            </summary>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Authentication.AuthenticationProvider.SignSHA256Bytes(System.Byte[])">
            <summary>
            SHA256 sign the data and return the bytes
            </summary>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Authentication.AuthenticationProvider.SignSHA256(System.String,System.Nullable{CryptoExchange.Net.Authentication.SignOutputType})">
            <summary>
            SHA256 sign the data and return the hash
            </summary>
            <param name="data">Data to sign</param>
            <param name="outputType">String type</param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Authentication.AuthenticationProvider.SignSHA256(System.Byte[],System.Nullable{CryptoExchange.Net.Authentication.SignOutputType})">
            <summary>
            SHA256 sign the data and return the hash
            </summary>
            <param name="data">Data to sign</param>
            <param name="outputType">String type</param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Authentication.AuthenticationProvider.SignSHA384(System.String,System.Nullable{CryptoExchange.Net.Authentication.SignOutputType})">
            <summary>
            SHA384 sign the data and return the hash
            </summary>
            <param name="data">Data to sign</param>
            <param name="outputType">String type</param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Authentication.AuthenticationProvider.SignSHA384(System.Byte[],System.Nullable{CryptoExchange.Net.Authentication.SignOutputType})">
            <summary>
            SHA384 sign the data and return the hash
            </summary>
            <param name="data">Data to sign</param>
            <param name="outputType">String type</param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Authentication.AuthenticationProvider.SignSHA384Bytes(System.String)">
            <summary>
            SHA384 sign the data and return the hash
            </summary>
            <param name="data">Data to sign</param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Authentication.AuthenticationProvider.SignSHA384Bytes(System.Byte[])">
            <summary>
            SHA384 sign the data and return the hash
            </summary>
            <param name="data">Data to sign</param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Authentication.AuthenticationProvider.SignSHA512(System.String,System.Nullable{CryptoExchange.Net.Authentication.SignOutputType})">
            <summary>
            SHA512 sign the data and return the hash
            </summary>
            <param name="data">Data to sign</param>
            <param name="outputType">String type</param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Authentication.AuthenticationProvider.SignSHA512(System.Byte[],System.Nullable{CryptoExchange.Net.Authentication.SignOutputType})">
            <summary>
            SHA512 sign the data and return the hash
            </summary>
            <param name="data">Data to sign</param>
            <param name="outputType">String type</param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Authentication.AuthenticationProvider.SignSHA512Bytes(System.String)">
            <summary>
            SHA512 sign the data and return the hash
            </summary>
            <param name="data">Data to sign</param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Authentication.AuthenticationProvider.SignSHA512Bytes(System.Byte[])">
            <summary>
            SHA512 sign the data and return the hash
            </summary>
            <param name="data">Data to sign</param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Authentication.AuthenticationProvider.SignMD5(System.String,System.Nullable{CryptoExchange.Net.Authentication.SignOutputType})">
            <summary>
            MD5 sign the data and return the hash
            </summary>
            <param name="data">Data to sign</param>
            <param name="outputType">String type</param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Authentication.AuthenticationProvider.SignMD5(System.Byte[],System.Nullable{CryptoExchange.Net.Authentication.SignOutputType})">
            <summary>
            MD5 sign the data and return the hash
            </summary>
            <param name="data">Data to sign</param>
            <param name="outputType">String type</param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Authentication.AuthenticationProvider.SignMD5Bytes(System.String)">
            <summary>
            MD5 sign the data and return the hash
            </summary>
            <param name="data">Data to sign</param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Authentication.AuthenticationProvider.SignHMACSHA256(System.String,System.Nullable{CryptoExchange.Net.Authentication.SignOutputType})">
            <summary>
            HMACSHA256 sign the data and return the hash
            </summary>
            <param name="data">Data to sign</param>
            <param name="outputType">String type</param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Authentication.AuthenticationProvider.SignHMACSHA256(System.Byte[],System.Nullable{CryptoExchange.Net.Authentication.SignOutputType})">
            <summary>
            HMACSHA256 sign the data and return the hash
            </summary>
            <param name="data">Data to sign</param>
            <param name="outputType">String type</param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Authentication.AuthenticationProvider.SignHMACSHA384(System.String,System.Nullable{CryptoExchange.Net.Authentication.SignOutputType})">
            <summary>
            HMACSHA384 sign the data and return the hash
            </summary>
            <param name="data">Data to sign</param>
            <param name="outputType">String type</param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Authentication.AuthenticationProvider.SignHMACSHA384(System.Byte[],System.Nullable{CryptoExchange.Net.Authentication.SignOutputType})">
            <summary>
            HMACSHA384 sign the data and return the hash
            </summary>
            <param name="data">Data to sign</param>
            <param name="outputType">String type</param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Authentication.AuthenticationProvider.SignHMACSHA512(System.String,System.Nullable{CryptoExchange.Net.Authentication.SignOutputType})">
            <summary>
            HMACSHA512 sign the data and return the hash
            </summary>
            <param name="data">Data to sign</param>
            <param name="outputType">String type</param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Authentication.AuthenticationProvider.SignHMACSHA512(System.Byte[],System.Nullable{CryptoExchange.Net.Authentication.SignOutputType})">
            <summary>
            HMACSHA512 sign the data and return the hash
            </summary>
            <param name="data">Data to sign</param>
            <param name="outputType">String type</param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Authentication.AuthenticationProvider.SignRSASHA256(System.Byte[],System.Nullable{CryptoExchange.Net.Authentication.SignOutputType})">
            <summary>
            SHA256 sign the data
            </summary>
            <param name="data"></param>
            <param name="outputType"></param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Authentication.AuthenticationProvider.SignRSASHA384(System.Byte[],System.Nullable{CryptoExchange.Net.Authentication.SignOutputType})">
            <summary>
            SHA384 sign the data
            </summary>
            <param name="data"></param>
            <param name="outputType"></param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Authentication.AuthenticationProvider.SignRSASHA512(System.Byte[],System.Nullable{CryptoExchange.Net.Authentication.SignOutputType})">
            <summary>
            SHA512 sign the data
            </summary>
            <param name="data"></param>
            <param name="outputType"></param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Authentication.AuthenticationProvider.BytesToHexString(System.Byte[])">
            <summary>
            Convert byte array to hex string
            </summary>
            <param name="buff"></param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Authentication.AuthenticationProvider.BytesToBase64String(System.Byte[])">
            <summary>
            Convert byte array to base64 string
            </summary>
            <param name="buff"></param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Authentication.AuthenticationProvider.GetTimestamp(CryptoExchange.Net.Clients.RestApiClient)">
            <summary>
            Get current timestamp including the time sync offset from the api client
            </summary>
            <param name="apiClient"></param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Authentication.AuthenticationProvider.GetMillisecondTimestamp(CryptoExchange.Net.Clients.RestApiClient)">
            <summary>
            Get millisecond timestamp as a string including the time sync offset from the api client
            </summary>
            <param name="apiClient"></param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Authentication.AuthenticationProvider.Dispose">
            <inheritdoc />
        </member>
        <member name="T:CryptoExchange.Net.Authentication.AuthenticationProvider`1">
            <inheritdoc />
        </member>
        <member name="P:CryptoExchange.Net.Authentication.AuthenticationProvider`1._credentials">
            <inheritdoc />
        </member>
        <member name="M:CryptoExchange.Net.Authentication.AuthenticationProvider`1.#ctor(`0)">
            <summary>
            ctor
            </summary>
            <param name="credentials"></param>
        </member>
        <member name="T:CryptoExchange.Net.Authentication.SignOutputType">
            <summary>
            Output string type
            </summary>
        </member>
        <member name="F:CryptoExchange.Net.Authentication.SignOutputType.Hex">
            <summary>
            Hex string
            </summary>
        </member>
        <member name="F:CryptoExchange.Net.Authentication.SignOutputType.Base64">
            <summary>
            Base64 string
            </summary>
        </member>
        <member name="T:CryptoExchange.Net.Clients.BaseApiClient">
            <summary>
            Base API for all API clients
            </summary>
        </member>
        <member name="F:CryptoExchange.Net.Clients.BaseApiClient._logger">
            <summary>
            Logger
            </summary>
        </member>
        <member name="F:CryptoExchange.Net.Clients.BaseApiClient._disposing">
            <summary>
            If we are disposing
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Clients.BaseApiClient.AuthenticationProvider">
            <summary>
            The authentication provider for this API client. (null if no credentials are set)
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Clients.BaseApiClient.BaseAddress">
            <summary>
            The environment this client communicates to
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Clients.BaseApiClient.OutputOriginalData">
            <summary>
            Output the original string data along with the deserialized object
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Clients.BaseApiClient.ApiOptions">
            <summary>
            Api options
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Clients.BaseApiClient.ClientOptions">
            <summary>
            Client Options
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.Clients.BaseApiClient.#ctor(Microsoft.Extensions.Logging.ILogger,System.Boolean,CryptoExchange.Net.Authentication.ApiCredentials,System.String,CryptoExchange.Net.Objects.Options.ExchangeOptions,CryptoExchange.Net.Objects.Options.ApiOptions)">
            <summary>
            ctor
            </summary>
            <param name="logger">Logger</param>
            <param name="outputOriginalData">Should data from this client include the orginal data in the call result</param>
            <param name="baseAddress">Base address for this API client</param>
            <param name="apiCredentials">Api credentials</param>
            <param name="clientOptions">Client options</param>
            <param name="apiOptions">Api options</param>
        </member>
        <member name="M:CryptoExchange.Net.Clients.BaseApiClient.CreateAuthenticationProvider(CryptoExchange.Net.Authentication.ApiCredentials)">
            <summary>
            Create an AuthenticationProvider implementation instance based on the provided credentials
            </summary>
            <param name="credentials"></param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Clients.BaseApiClient.FormatSymbol(System.String,System.String)">
            <inheritdoc />
        </member>
        <member name="M:CryptoExchange.Net.Clients.BaseApiClient.SetApiCredentials``1(``0)">
            <inheritdoc />
        </member>
        <member name="M:CryptoExchange.Net.Clients.BaseApiClient.Dispose">
            <summary>
            Dispose
            </summary>
        </member>
        <member name="T:CryptoExchange.Net.Clients.BaseClient">
            <summary>
            The base for all clients, websocket client and rest client
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Clients.BaseClient.Exchange">
            <summary>
            The name of the API the client is for
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Clients.BaseClient.ApiClients">
            <summary>
            Api clients in this client
            </summary>
        </member>
        <member name="F:CryptoExchange.Net.Clients.BaseClient._logger">
            <summary>
            The log object
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Clients.BaseClient.ClientOptions">
            <summary>
            Provided client options
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.Clients.BaseClient.#ctor(Microsoft.Extensions.Logging.ILoggerFactory,System.String)">
            <summary>
            ctor
            </summary>
            <param name="logger">Logger</param>
            <param name="exchange">The name of the exchange this client is for</param>
        </member>
        <member name="M:CryptoExchange.Net.Clients.BaseClient.Initialize(CryptoExchange.Net.Objects.Options.ExchangeOptions)">
            <summary>
            Initialize the client with the specified options
            </summary>
            <param name="options"></param>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:CryptoExchange.Net.Clients.BaseClient.SetApiCredentials``1(``0)">
            <summary>
            Set the API credentials for this client. All Api clients in this client will use the new credentials, regardless of earlier set options.
            </summary>
            <param name="credentials">The credentials to set</param>
        </member>
        <member name="M:CryptoExchange.Net.Clients.BaseClient.AddApiClient``1(``0)">
            <summary>
            Register an API client
            </summary>
            <param name="apiClient">The client</param>
        </member>
        <member name="M:CryptoExchange.Net.Clients.BaseClient.Dispose">
            <summary>
            Dispose
            </summary>
        </member>
        <member name="T:CryptoExchange.Net.Clients.BaseRestClient">
            <summary>
            Base rest client
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Clients.BaseRestClient.TotalRequestsMade">
            <inheritdoc />
        </member>
        <member name="M:CryptoExchange.Net.Clients.BaseRestClient.#ctor(Microsoft.Extensions.Logging.ILoggerFactory,System.String)">
            <summary>
            ctor
            </summary>
            <param name="loggerFactory">Logger factory</param>
            <param name="name">The name of the API this client is for</param>
        </member>
        <member name="T:CryptoExchange.Net.Clients.BaseSocketClient">
            <summary>
            Base for socket client implementations
            </summary>
        </member>
        <member name="F:CryptoExchange.Net.Clients.BaseSocketClient._disposing">
            <summary>
            If client is disposing
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Clients.BaseSocketClient.CurrentConnections">
            <inheritdoc />
        </member>
        <member name="P:CryptoExchange.Net.Clients.BaseSocketClient.CurrentSubscriptions">
            <inheritdoc />
        </member>
        <member name="P:CryptoExchange.Net.Clients.BaseSocketClient.IncomingKbps">
            <inheritdoc />
        </member>
        <member name="M:CryptoExchange.Net.Clients.BaseSocketClient.#ctor(Microsoft.Extensions.Logging.ILoggerFactory,System.String)">
            <summary>
            ctor
            </summary>
            <param name="logger">Logger</param>
            <param name="exchange">The name of the exchange this client is for</param>
        </member>
        <member name="M:CryptoExchange.Net.Clients.BaseSocketClient.UnsubscribeAsync(System.Int32)">
            <summary>
            Unsubscribe an update subscription
            </summary>
            <param name="subscriptionId">The id of the subscription to unsubscribe</param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Clients.BaseSocketClient.UnsubscribeAsync(CryptoExchange.Net.Objects.Sockets.UpdateSubscription)">
            <summary>
            Unsubscribe an update subscription
            </summary>
            <param name="subscription">The subscription to unsubscribe</param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Clients.BaseSocketClient.UnsubscribeAllAsync">
            <summary>
            Unsubscribe all subscriptions
            </summary>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Clients.BaseSocketClient.ReconnectAsync">
            <summary>
            Reconnect all connections
            </summary>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Clients.BaseSocketClient.GetSubscriptionsState">
            <summary>
            Log the current state of connections and subscriptions
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.Clients.BaseSocketClient.GetSocketApiClientStates">
            <summary>
            Returns the state of all socket api clients
            </summary>
            <returns></returns>
        </member>
        <member name="T:CryptoExchange.Net.Clients.CryptoBaseClient">
            <summary>
            Base crypto client
            </summary>
        </member>
        <member name="F:CryptoExchange.Net.Clients.CryptoBaseClient._serviceProvider">
            <summary>
            Service provider
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.Clients.CryptoBaseClient.#ctor">
            <summary>
            ctor
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.Clients.CryptoBaseClient.#ctor(System.IServiceProvider)">
            <summary>
            ctor
            </summary>
            <param name="serviceProvider"></param>
        </member>
        <member name="M:CryptoExchange.Net.Clients.CryptoBaseClient.TryGet``1(System.Func{``0})">
            <summary>
            Try get a client by type for the service collection
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Clients.CryptoBaseClient.Dispose">
            <summary>
            Dispose
            </summary>
        </member>
        <member name="T:CryptoExchange.Net.Clients.CryptoRestClient">
            <inheritdoc />
        </member>
        <member name="M:CryptoExchange.Net.Clients.CryptoRestClient.#ctor">
            <summary>
            ctor
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.Clients.CryptoRestClient.#ctor(System.IServiceProvider)">
            <summary>
            ctor
            </summary>
            <param name="serviceProvider"></param>
        </member>
        <member name="M:CryptoExchange.Net.Clients.CryptoRestClient.GetSpotClients">
            <summary>
            Get a list of the registered ISpotClient implementations
            </summary>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Clients.CryptoRestClient.SpotClient(System.String)">
            <summary>
            Get an ISpotClient implementation by exchange name
            </summary>
            <param name="exchangeName"></param>
            <returns></returns>
        </member>
        <member name="T:CryptoExchange.Net.Clients.CryptoSocketClient">
            <inheritdoc />
        </member>
        <member name="M:CryptoExchange.Net.Clients.CryptoSocketClient.#ctor">
            <summary>
            ctor
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.Clients.CryptoSocketClient.#ctor(System.IServiceProvider)">
            <summary>
            ctor
            </summary>
            <param name="serviceProvider"></param>
        </member>
        <member name="T:CryptoExchange.Net.Clients.RestApiClient">
            <summary>
            Base rest API client for interacting with a REST API
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Clients.RestApiClient.RequestFactory">
            <inheritdoc />
        </member>
        <member name="M:CryptoExchange.Net.Clients.RestApiClient.GetTimeSyncInfo">
            <inheritdoc />
        </member>
        <member name="M:CryptoExchange.Net.Clients.RestApiClient.GetTimeOffset">
            <inheritdoc />
        </member>
        <member name="P:CryptoExchange.Net.Clients.RestApiClient.TotalRequestsMade">
            <inheritdoc />
        </member>
        <member name="F:CryptoExchange.Net.Clients.RestApiClient.RequestBodyFormat">
            <summary>
            Request body content type
            </summary>
        </member>
        <member name="F:CryptoExchange.Net.Clients.RestApiClient.ArraySerialization">
            <summary>
            How to serialize array parameters when making requests
            </summary>
        </member>
        <member name="F:CryptoExchange.Net.Clients.RestApiClient.RequestBodyEmptyContent">
            <summary>
            What request body should be set when no data is send (only used in combination with postParametersPosition.InBody)
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Clients.RestApiClient.StandardRequestHeaders">
            <summary>
            Request headers to be sent with each request
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Clients.RestApiClient.OrderParameters">
            <summary>
            Whether parameters need to be ordered
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Clients.RestApiClient.ParameterOrderComparer">
            <summary>
            Parameter order comparer
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Clients.RestApiClient.ParameterPositions">
            <summary>
            Where to put the parameters for requests with different Http methods
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Clients.RestApiClient.ClientOptions">
            <inheritdoc />
        </member>
        <member name="P:CryptoExchange.Net.Clients.RestApiClient.ApiOptions">
            <inheritdoc />
        </member>
        <member name="M:CryptoExchange.Net.Clients.RestApiClient.#ctor(Microsoft.Extensions.Logging.ILogger,System.Net.Http.HttpClient,System.String,CryptoExchange.Net.Objects.Options.RestExchangeOptions,CryptoExchange.Net.Objects.Options.RestApiOptions)">
            <summary>
            ctor
            </summary>
            <param name="logger">Logger</param>
            <param name="httpClient">HttpClient to use</param>
            <param name="baseAddress">Base address for this API client</param>
            <param name="options">The base client options</param>
            <param name="apiOptions">The Api client options</param>
        </member>
        <member name="M:CryptoExchange.Net.Clients.RestApiClient.CreateAccessor">
            <summary>
            Create a message accessor instance
            </summary>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Clients.RestApiClient.CreateSerializer">
            <summary>
            Create a serializer instance
            </summary>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Clients.RestApiClient.SendAsync(System.String,CryptoExchange.Net.Objects.RequestDefinition,CryptoExchange.Net.Objects.ParameterCollection,System.Threading.CancellationToken,System.Collections.Generic.Dictionary{System.String,System.String},System.Nullable{System.Int32})">
            <summary>
            Send a request to the base address based on the request definition
            </summary>
            <param name="baseAddress">Host and schema</param>
            <param name="definition">Request definition</param>
            <param name="parameters">Request parameters</param>
            <param name="cancellationToken">Cancellation token</param>
            <param name="additionalHeaders">Additional headers for this request</param>
            <param name="weight">Override the request weight for this request definition, for example when the weight depends on the parameters</param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Clients.RestApiClient.SendAsync``1(System.String,CryptoExchange.Net.Objects.RequestDefinition,CryptoExchange.Net.Objects.ParameterCollection,System.Threading.CancellationToken,System.Collections.Generic.Dictionary{System.String,System.String},System.Nullable{System.Int32})">
            <summary>
            Send a request to the base address based on the request definition
            </summary>
            <typeparam name="T">Response type</typeparam>
            <param name="baseAddress">Host and schema</param>
            <param name="definition">Request definition</param>
            <param name="parameters">Request parameters</param>
            <param name="cancellationToken">Cancellation token</param>
            <param name="additionalHeaders">Additional headers for this request</param>
            <param name="weight">Override the request weight for this request definition, for example when the weight depends on the parameters</param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Clients.RestApiClient.PrepareAsync(System.String,CryptoExchange.Net.Objects.RequestDefinition,CryptoExchange.Net.Objects.ParameterCollection,System.Threading.CancellationToken,System.Collections.Generic.Dictionary{System.String,System.String},System.Nullable{System.Int32})">
            <summary>
            Prepare before sending a request. Sync time between client and server and check rate limits
            </summary>
            <param name="baseAddress">Host and schema</param>
            <param name="definition">Request definition</param>
            <param name="parameters">Request parameters</param>
            <param name="cancellationToken">Cancellation token</param>
            <param name="additionalHeaders">Additional headers for this request</param>
            <param name="weight">Override the request weight for this request</param>
            <returns></returns>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="M:CryptoExchange.Net.Clients.RestApiClient.CreateRequest(System.String,CryptoExchange.Net.Objects.RequestDefinition,CryptoExchange.Net.Objects.ParameterCollection,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Creates a request object
            </summary>
            <param name="baseAddress">Host and schema</param>
            <param name="definition">Request definition</param>
            <param name="parameters">The parameters of the request</param>
            <param name="additionalHeaders">Additional headers to send with the request</param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Clients.RestApiClient.SendRequestAsync(System.Uri,System.Net.Http.HttpMethod,System.Threading.CancellationToken,System.Collections.Generic.Dictionary{System.String,System.Object},System.Boolean,System.Nullable{CryptoExchange.Net.Objects.RequestBodyFormat},System.Nullable{CryptoExchange.Net.Objects.HttpMethodParameterPosition},System.Nullable{CryptoExchange.Net.Objects.ArrayParametersSerialization},System.Int32,System.Collections.Generic.Dictionary{System.String,System.String},CryptoExchange.Net.RateLimiting.Interfaces.IRateLimitGate)">
            <summary>
            Execute a request to the uri and returns if it was successful
            </summary>
            <param name="uri">The uri to send the request to</param>
            <param name="method">The method of the request</param>
            <param name="cancellationToken">Cancellation token</param>
            <param name="parameters">The parameters of the request</param>
            <param name="signed">Whether or not the request should be authenticated</param>
            <param name="requestBodyFormat">The format of the body content</param>
            <param name="parameterPosition">Where the parameters should be placed, overwrites the value set in the client</param>
            <param name="arraySerialization">How array parameters should be serialized, overwrites the value set in the client</param>
            <param name="requestWeight">Credits used for the request</param>
            <param name="additionalHeaders">Additional headers to send with the request</param>
            <param name="gate">The ratelimit gate to use</param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Clients.RestApiClient.SendRequestAsync``1(System.Uri,System.Net.Http.HttpMethod,System.Threading.CancellationToken,System.Collections.Generic.Dictionary{System.String,System.Object},System.Boolean,System.Nullable{CryptoExchange.Net.Objects.RequestBodyFormat},System.Nullable{CryptoExchange.Net.Objects.HttpMethodParameterPosition},System.Nullable{CryptoExchange.Net.Objects.ArrayParametersSerialization},System.Int32,System.Collections.Generic.Dictionary{System.String,System.String},CryptoExchange.Net.RateLimiting.Interfaces.IRateLimitGate)">
            <summary>
            Execute a request to the uri and deserialize the response into the provided type parameter
            </summary>
            <typeparam name="T">The type to deserialize into</typeparam>
            <param name="uri">The uri to send the request to</param>
            <param name="method">The method of the request</param>
            <param name="cancellationToken">Cancellation token</param>
            <param name="parameters">The parameters of the request</param>
            <param name="signed">Whether or not the request should be authenticated</param>
            <param name="requestBodyFormat">The format of the body content</param>
            <param name="parameterPosition">Where the parameters should be placed, overwrites the value set in the client</param>
            <param name="arraySerialization">How array parameters should be serialized, overwrites the value set in the client</param>
            <param name="requestWeight">Credits used for the request</param>
            <param name="additionalHeaders">Additional headers to send with the request</param>
            <param name="gate">The ratelimit gate to use</param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Clients.RestApiClient.PrepareRequestAsync(System.Uri,System.Net.Http.HttpMethod,System.Threading.CancellationToken,System.Collections.Generic.Dictionary{System.String,System.Object},System.Boolean,System.Nullable{CryptoExchange.Net.Objects.RequestBodyFormat},System.Nullable{CryptoExchange.Net.Objects.HttpMethodParameterPosition},System.Nullable{CryptoExchange.Net.Objects.ArrayParametersSerialization},System.Int32,System.Collections.Generic.Dictionary{System.String,System.String},CryptoExchange.Net.RateLimiting.Interfaces.IRateLimitGate)">
            <summary>
            Prepares a request to be sent to the server
            </summary>
            <param name="uri">The uri to send the request to</param>
            <param name="method">The method of the request</param>
            <param name="cancellationToken">Cancellation token</param>
            <param name="parameters">The parameters of the request</param>
            <param name="signed">Whether or not the request should be authenticated</param>
            <param name="requestBodyFormat">The format of the body content</param>
            <param name="parameterPosition">Where the parameters should be placed, overwrites the value set in the client</param>
            <param name="arraySerialization">How array parameters should be serialized, overwrites the value set in the client</param>
            <param name="requestWeight">Credits used for the request</param>
            <param name="additionalHeaders">Additional headers to send with the request</param>
            <param name="gate">The rate limit gate to use</param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Clients.RestApiClient.GetResponseAsync``1(CryptoExchange.Net.Interfaces.IRequest,CryptoExchange.Net.RateLimiting.Interfaces.IRateLimitGate,System.Threading.CancellationToken)">
            <summary>
            Executes the request and returns the result deserialized into the type parameter class
            </summary>
            <param name="request">The request object to execute</param>
            <param name="gate">The ratelimit gate used</param>
            <param name="cancellationToken">Cancellation token</param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Clients.RestApiClient.TryParseError(CryptoExchange.Net.Interfaces.IMessageAccessor)">
            <summary>
            Can be used to parse an error even though response status indicates success. Some apis always return 200 OK, even though there is an error.
            When setting manualParseError to true this method will be called for each response to be able to check if the response is an error or not.
            If the response is an error this method should return the parsed error, else it should return null
            </summary>
            <param name="accessor">Data accessor</param>
            <returns>Null if not an error, Error otherwise</returns>
        </member>
        <member name="M:CryptoExchange.Net.Clients.RestApiClient.ShouldRetryRequestAsync``1(CryptoExchange.Net.RateLimiting.Interfaces.IRateLimitGate,CryptoExchange.Net.Objects.WebCallResult{``0},System.Int32)">
            <summary>
            Can be used to indicate that a request should be retried. Defaults to false. Make sure to retry a max number of times (based on the the tries parameter) or the request will retry forever.
            Note that this is always called; even when the request might be successful
            </summary>
            <typeparam name="T">WebCallResult type parameter</typeparam>
            <param name="gate">The rate limit gate the call used</param>
            <param name="callResult">The result of the call</param>
            <param name="tries">The current try number</param>
            <returns>True if call should retry, false if the call should return</returns>
        </member>
        <member name="M:CryptoExchange.Net.Clients.RestApiClient.ConstructRequest(System.Uri,System.Net.Http.HttpMethod,System.Collections.Generic.Dictionary{System.String,System.Object},System.Boolean,CryptoExchange.Net.Objects.HttpMethodParameterPosition,CryptoExchange.Net.Objects.ArrayParametersSerialization,CryptoExchange.Net.Objects.RequestBodyFormat,System.Int32,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Creates a request object
            </summary>
            <param name="uri">The uri to send the request to</param>
            <param name="method">The method of the request</param>
            <param name="parameters">The parameters of the request</param>
            <param name="signed">Whether or not the request should be authenticated</param>
            <param name="parameterPosition">Where the parameters should be placed</param>
            <param name="arraySerialization">How array parameters should be serialized</param>
            <param name="bodyFormat">Format of the body content</param>
            <param name="requestId">Unique id of a request</param>
            <param name="additionalHeaders">Additional headers to send with the request</param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Clients.RestApiClient.WriteParamBody(CryptoExchange.Net.Interfaces.IRequest,System.Collections.Generic.IDictionary{System.String,System.Object},System.String)">
            <summary>
            Writes the parameters of the request to the request object body
            </summary>
            <param name="request">The request to set the parameters on</param>
            <param name="parameters">The parameters to set</param>
            <param name="contentType">The content type of the data</param>
        </member>
        <member name="M:CryptoExchange.Net.Clients.RestApiClient.ParseErrorResponse(System.Int32,System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.Collections.Generic.IEnumerable{System.String}}},CryptoExchange.Net.Interfaces.IMessageAccessor)">
            <summary>
            Parse an error response from the server. Only used when server returns a status other than Success(200) or ratelimit error (429 or 418)
            </summary>
            <param name="httpStatusCode">The response status code</param>
            <param name="responseHeaders">The response headers</param>
            <param name="accessor">Data accessor</param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Clients.RestApiClient.ParseRateLimitResponse(System.Int32,System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.Collections.Generic.IEnumerable{System.String}}},CryptoExchange.Net.Interfaces.IMessageAccessor)">
            <summary>
            Parse a rate limit error response from the server. Only used when server returns http status 429 or 418
            </summary>
            <param name="httpStatusCode">The response status code</param>
            <param name="responseHeaders">The response headers</param>
            <param name="accessor">Data accessor</param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Clients.RestApiClient.CreateParameterDictionary(System.Collections.Generic.IDictionary{System.String,System.Object})">
            <summary>
            Create the parameter IDictionary
            </summary>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Clients.RestApiClient.GetServerTimestampAsync">
            <summary>
            Retrieve the server time for the purpose of syncing time between client and server to prevent authentication issues
            </summary>
            <returns>Server time</returns>
        </member>
        <member name="T:CryptoExchange.Net.Clients.SocketApiClient">
            <summary>
            Base socket API client for interaction with a websocket API
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Clients.SocketApiClient.SocketFactory">
            <inheritdoc/>
        </member>
        <member name="F:CryptoExchange.Net.Clients.SocketApiClient.socketConnections">
            <summary>
            List of socket connections currently connecting/connected
            </summary>
        </member>
        <member name="F:CryptoExchange.Net.Clients.SocketApiClient.semaphoreSlim">
            <summary>
            Semaphore used while creating sockets
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Clients.SocketApiClient.KeepAliveInterval">
            <summary>
            Keep alive interval for websocket connection
            </summary>
        </member>
        <member name="F:CryptoExchange.Net.Clients.SocketApiClient.systemSubscriptions">
            <summary>
            Handlers for data from the socket which doesn't need to be forwarded to the caller. Ping or welcome messages for example.
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Clients.SocketApiClient.UnhandledMessageExpected">
            <summary>
            If a message is received on the socket which is not handled by a handler this boolean determines whether this logs an error message
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Clients.SocketApiClient.HandleMessageBeforeConfirmation">
            <summary>
            If true a subscription will accept message before the confirmation of a subscription has been received
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Clients.SocketApiClient.RateLimiter">
            <summary>
            The rate limiters 
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Clients.SocketApiClient.MessageSendSizeLimit">
            <summary>
            The max size a websocket message size can be
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Clients.SocketApiClient.PeriodicTaskRegistrations">
            <summary>
            Periodic task registrations
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Clients.SocketApiClient.IncomingKbps">
            <inheritdoc />
        </member>
        <member name="P:CryptoExchange.Net.Clients.SocketApiClient.CurrentConnections">
            <inheritdoc />
        </member>
        <member name="P:CryptoExchange.Net.Clients.SocketApiClient.CurrentSubscriptions">
            <inheritdoc />
        </member>
        <member name="P:CryptoExchange.Net.Clients.SocketApiClient.ClientOptions">
            <inheritdoc />
        </member>
        <member name="P:CryptoExchange.Net.Clients.SocketApiClient.ApiOptions">
            <inheritdoc />
        </member>
        <member name="M:CryptoExchange.Net.Clients.SocketApiClient.#ctor(Microsoft.Extensions.Logging.ILogger,System.String,CryptoExchange.Net.Objects.Options.SocketExchangeOptions,CryptoExchange.Net.Objects.Options.SocketApiOptions)">
            <summary>
            ctor
            </summary>
            <param name="logger">log</param>
            <param name="options">Client options</param>
            <param name="baseAddress">Base address for this API client</param>
            <param name="apiOptions">The Api client options</param>
        </member>
        <member name="M:CryptoExchange.Net.Clients.SocketApiClient.CreateAccessor">
            <summary>
            Create a message accessor instance
            </summary>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Clients.SocketApiClient.CreateSerializer">
            <summary>
            Create a serializer instance
            </summary>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Clients.SocketApiClient.RegisterPeriodicQuery(System.String,System.TimeSpan,System.Func{CryptoExchange.Net.Sockets.SocketConnection,CryptoExchange.Net.Sockets.Query},System.Action{CryptoExchange.Net.Objects.CallResult})">
            <summary>
            Add a query to periodically send on each connection
            </summary>
            <param name="identifier"></param>
            <param name="interval"></param>
            <param name="queryDelegate"></param>
            <param name="callback"></param>
        </member>
        <member name="M:CryptoExchange.Net.Clients.SocketApiClient.SubscribeAsync(CryptoExchange.Net.Sockets.Subscription,System.Threading.CancellationToken)">
            <summary>
            Connect to an url and listen for data on the BaseAddress
            </summary>
            <param name="subscription">The subscription</param>
            <param name="ct">Cancellation token for closing this subscription</param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Clients.SocketApiClient.SubscribeAsync(System.String,CryptoExchange.Net.Sockets.Subscription,System.Threading.CancellationToken)">
            <summary>
            Connect to an url and listen for data
            </summary>
            <param name="url">The URL to connect to</param>
            <param name="subscription">The subscription</param>
            <param name="ct">Cancellation token for closing this subscription</param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Clients.SocketApiClient.QueryAsync``1(CryptoExchange.Net.Sockets.Query{``0})">
            <summary>
            Send a query on a socket connection to the BaseAddress and wait for the response
            </summary>
            <typeparam name="T">Expected result type</typeparam>
            <param name="query">The query</param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Clients.SocketApiClient.QueryAsync``1(System.String,CryptoExchange.Net.Sockets.Query{``0})">
            <summary>
            Send a query on a socket connection and wait for the response
            </summary>
            <typeparam name="T">The expected result type</typeparam>
            <param name="url">The url for the request</param>
            <param name="query">The query</param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Clients.SocketApiClient.ConnectIfNeededAsync(CryptoExchange.Net.Sockets.SocketConnection,System.Boolean)">
            <summary>
            Checks if a socket needs to be connected and does so if needed. Also authenticates on the socket if needed
            </summary>
            <param name="socket">The connection to check</param>
            <param name="authenticated">Whether the socket should authenticated</param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Clients.SocketApiClient.AuthenticateSocketAsync(CryptoExchange.Net.Sockets.SocketConnection)">
            <summary>
            Authenticate a socket connection
            </summary>
            <param name="socket">Socket to authenticate</param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Clients.SocketApiClient.GetAuthenticationRequest">
            <summary>
            Should return the request which can be used to authenticate a socket connection
            </summary>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Clients.SocketApiClient.AddSystemSubscription(CryptoExchange.Net.Sockets.SystemSubscription)">
            <summary>
            Adds a system subscription. Used for example to reply to ping requests
            </summary>
            <param name="systemSubscription">The subscription</param>
        </member>
        <member name="M:CryptoExchange.Net.Clients.SocketApiClient.GetConnectionUrlAsync(System.String,System.Boolean)">
            <summary>
            Get the url to connect to (defaults to BaseAddress form the client options)
            </summary>
            <param name="address"></param>
            <param name="authentication"></param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Clients.SocketApiClient.GetReconnectUriAsync(CryptoExchange.Net.Sockets.SocketConnection)">
            <summary>
            Get the url to reconnect to after losing a connection
            </summary>
            <param name="connection"></param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Clients.SocketApiClient.RevitalizeRequestAsync(CryptoExchange.Net.Sockets.Subscription)">
            <summary>
            Update the subscription when the connection is restored after disconnecting. Can be used to update an authentication token for example.
            </summary>
            <param name="subscription">The subscription</param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Clients.SocketApiClient.GetSocketConnection(System.String,System.Boolean)">
            <summary>
            Gets a connection for a new subscription or query. Can be an existing if there are open position or a new one.
            </summary>
            <param name="address">The address the socket is for</param>
            <param name="authenticated">Whether the socket should be authenticated</param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Clients.SocketApiClient.HandleUnhandledMessage(CryptoExchange.Net.Interfaces.IMessageAccessor)">
            <summary>
            Process an unhandled message
            </summary>
            <param name="message">The message that wasn't processed</param>
        </member>
        <member name="M:CryptoExchange.Net.Clients.SocketApiClient.ConnectSocketAsync(CryptoExchange.Net.Sockets.SocketConnection)">
            <summary>
            Connect a socket
            </summary>
            <param name="socketConnection">The socket to connect</param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Clients.SocketApiClient.GetWebSocketParameters(System.String)">
            <summary>
            Get parameters for the websocket connection
            </summary>
            <param name="address">The address to connect to</param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Clients.SocketApiClient.CreateSocket(System.String)">
            <summary>
            Create a socket for an address
            </summary>
            <param name="address">The address the socket should connect to</param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Clients.SocketApiClient.UnsubscribeAsync(System.Int32)">
            <summary>
            Unsubscribe an update subscription
            </summary>
            <param name="subscriptionId">The id of the subscription to unsubscribe</param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Clients.SocketApiClient.UnsubscribeAsync(CryptoExchange.Net.Objects.Sockets.UpdateSubscription)">
            <summary>
            Unsubscribe an update subscription
            </summary>
            <param name="subscription">The subscription to unsubscribe</param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Clients.SocketApiClient.UnsubscribeAllAsync">
            <summary>
            Unsubscribe all subscriptions
            </summary>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Clients.SocketApiClient.ReconnectAsync">
            <summary>
            Reconnect all connections
            </summary>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Clients.SocketApiClient.GetSubscriptionsState(System.Boolean)">
            <summary>
            Log the current state of connections and subscriptions
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.Clients.SocketApiClient.GetState(System.Boolean)">
            <summary>
            Gets the state of the client
            </summary>
            <param name="includeSubDetails">True to get details for each subscription</param>
            <returns></returns>
        </member>
        <member name="T:CryptoExchange.Net.Clients.SocketApiClient.SocketApiClientState">
            <summary>
            Get the current state of the client
            </summary>
            <param name="Connections">Number of sockets for this client</param>
            <param name="Subscriptions">Total number of subscriptions</param>
            <param name="DownloadSpeed">Total download speed</param>
            <param name="ConnectionStates">State of each socket connection</param>
        </member>
        <member name="M:CryptoExchange.Net.Clients.SocketApiClient.SocketApiClientState.#ctor(System.Int32,System.Int32,System.Double,System.Collections.Generic.List{CryptoExchange.Net.Sockets.SocketConnection.SocketConnectionState})">
            <summary>
            Get the current state of the client
            </summary>
            <param name="Connections">Number of sockets for this client</param>
            <param name="Subscriptions">Total number of subscriptions</param>
            <param name="DownloadSpeed">Total download speed</param>
            <param name="ConnectionStates">State of each socket connection</param>
        </member>
        <member name="P:CryptoExchange.Net.Clients.SocketApiClient.SocketApiClientState.Connections">
            <summary>Number of sockets for this client</summary>
        </member>
        <member name="P:CryptoExchange.Net.Clients.SocketApiClient.SocketApiClientState.Subscriptions">
            <summary>Total number of subscriptions</summary>
        </member>
        <member name="P:CryptoExchange.Net.Clients.SocketApiClient.SocketApiClientState.DownloadSpeed">
            <summary>Total download speed</summary>
        </member>
        <member name="P:CryptoExchange.Net.Clients.SocketApiClient.SocketApiClientState.ConnectionStates">
            <summary>State of each socket connection</summary>
        </member>
        <member name="M:CryptoExchange.Net.Clients.SocketApiClient.SocketApiClientState.PrintMembers(System.Text.StringBuilder)">
            <summary>
            Print the state of the client
            </summary>
            <param name="sb"></param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Clients.SocketApiClient.Dispose">
            <summary>
            Dispose the client
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.Clients.SocketApiClient.GetListenerIdentifier(CryptoExchange.Net.Interfaces.IMessageAccessor)">
            <summary>
            Get the listener identifier for the message
            </summary>
            <param name="messageAccessor"></param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Clients.SocketApiClient.PreprocessStreamMessage(System.Net.WebSockets.WebSocketMessageType,System.ReadOnlyMemory{System.Byte})">
            <summary>
            Preprocess a stream message
            </summary>
            <param name="type"></param>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="T:CryptoExchange.Net.CommonObjects.Balance">
            <summary>
            Balance data
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.CommonObjects.Balance.Asset">
            <summary>
            The asset name
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.CommonObjects.Balance.Available">
            <summary>
            Quantity available
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.CommonObjects.Balance.Total">
            <summary>
            Total quantity
            </summary>
        </member>
        <member name="T:CryptoExchange.Net.CommonObjects.BaseCommonObject">
            <summary>
            Base class for common objects
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.CommonObjects.BaseCommonObject.SourceObject">
            <summary>
            The source object the data is derived from
            </summary>
        </member>
        <member name="T:CryptoExchange.Net.CommonObjects.CommonOrderType">
            <summary>
            Order type
            </summary>
        </member>
        <member name="F:CryptoExchange.Net.CommonObjects.CommonOrderType.Limit">
            <summary>
            Limit type
            </summary>
        </member>
        <member name="F:CryptoExchange.Net.CommonObjects.CommonOrderType.Market">
            <summary>
            Market type
            </summary>
        </member>
        <member name="F:CryptoExchange.Net.CommonObjects.CommonOrderType.Other">
            <summary>
            Other order type
            </summary>
        </member>
        <member name="T:CryptoExchange.Net.CommonObjects.CommonOrderSide">
            <summary>
            Order side
            </summary>
        </member>
        <member name="F:CryptoExchange.Net.CommonObjects.CommonOrderSide.Buy">
            <summary>
            Buy order
            </summary>
        </member>
        <member name="F:CryptoExchange.Net.CommonObjects.CommonOrderSide.Sell">
            <summary>
            Sell order
            </summary>
        </member>
        <member name="T:CryptoExchange.Net.CommonObjects.CommonOrderStatus">
            <summary>
            Order status
            </summary>
        </member>
        <member name="F:CryptoExchange.Net.CommonObjects.CommonOrderStatus.Active">
            <summary>
            placed and not fully filled order
            </summary>
        </member>
        <member name="F:CryptoExchange.Net.CommonObjects.CommonOrderStatus.Canceled">
            <summary>
            canceled order
            </summary>
        </member>
        <member name="F:CryptoExchange.Net.CommonObjects.CommonOrderStatus.Filled">
            <summary>
            filled order
            </summary>
        </member>
        <member name="T:CryptoExchange.Net.CommonObjects.CommonPositionSide">
            <summary>
            Position side
            </summary>
        </member>
        <member name="F:CryptoExchange.Net.CommonObjects.CommonPositionSide.Long">
            <summary>
            Long position
            </summary>
        </member>
        <member name="F:CryptoExchange.Net.CommonObjects.CommonPositionSide.Short">
            <summary>
            Short position
            </summary>
        </member>
        <member name="F:CryptoExchange.Net.CommonObjects.CommonPositionSide.Both">
            <summary>
            Both
            </summary>
        </member>
        <member name="T:CryptoExchange.Net.CommonObjects.Kline">
            <summary>
            Kline data
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.CommonObjects.Kline.OpenTime">
            <summary>
            Opening time of the kline
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.CommonObjects.Kline.OpenPrice">
            <summary>
            Price at the open time
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.CommonObjects.Kline.HighPrice">
            <summary>
            Highest price of the kline
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.CommonObjects.Kline.LowPrice">
            <summary>
            Lowest price of the kline
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.CommonObjects.Kline.ClosePrice">
            <summary>
            Close price of the kline
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.CommonObjects.Kline.Volume">
            <summary>
            Volume of the kline
            </summary>
        </member>
        <member name="T:CryptoExchange.Net.CommonObjects.Order">
            <summary>
            Order data
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.CommonObjects.Order.Id">
            <summary>
            Id of the order
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.CommonObjects.Order.Symbol">
            <summary>
            Symbol of the order
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.CommonObjects.Order.Price">
            <summary>
            Price of the order
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.CommonObjects.Order.Quantity">
            <summary>
            Quantity of the order
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.CommonObjects.Order.QuantityFilled">
            <summary>
            The quantity of the order which has been filled
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.CommonObjects.Order.Status">
            <summary>
            Status of the order
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.CommonObjects.Order.Side">
            <summary>
            Side of the order
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.CommonObjects.Order.Type">
            <summary>
            Type of the order
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.CommonObjects.Order.Timestamp">
            <summary>
            Order time
            </summary>
        </member>
        <member name="T:CryptoExchange.Net.CommonObjects.OrderBook">
            <summary>
            Order book data
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.CommonObjects.OrderBook.Bids">
            <summary>
            List of bids
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.CommonObjects.OrderBook.Asks">
            <summary>
            List of asks
            </summary>
        </member>
        <member name="T:CryptoExchange.Net.CommonObjects.OrderBookEntry">
            <summary>
            Order book entry
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.CommonObjects.OrderBookEntry.Quantity">
            <summary>
            Quantity of the entry
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.CommonObjects.OrderBookEntry.Price">
            <summary>
            Price of the entry
            </summary>
        </member>
        <member name="T:CryptoExchange.Net.CommonObjects.OrderId">
            <summary>
            Id of an order
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.CommonObjects.OrderId.Id">
            <summary>
            Id of an order
            </summary>
        </member>
        <member name="T:CryptoExchange.Net.CommonObjects.Position">
            <summary>
            Position data
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.CommonObjects.Position.Id">
            <summary>
            Id of the position
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.CommonObjects.Position.Symbol">
            <summary>
            Symbol of the position
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.CommonObjects.Position.Leverage">
            <summary>
            Leverage
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.CommonObjects.Position.Quantity">
            <summary>
            Position quantity
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.CommonObjects.Position.EntryPrice">
            <summary>
            Entry price
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.CommonObjects.Position.LiquidationPrice">
            <summary>
            Liquidation price
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.CommonObjects.Position.UnrealizedPnl">
            <summary>
            Unrealized profit and loss
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.CommonObjects.Position.RealizedPnl">
            <summary>
            Realized profit and loss
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.CommonObjects.Position.MarkPrice">
            <summary>
            Mark price
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.CommonObjects.Position.AutoMargin">
            <summary>
            Auto adding margin
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.CommonObjects.Position.PositionMargin">
            <summary>
            Position margin
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.CommonObjects.Position.Side">
            <summary>
            Position side
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.CommonObjects.Position.Isolated">
            <summary>
            Is isolated
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.CommonObjects.Position.MaintananceMargin">
            <summary>
            Maintenance margin
            </summary>
        </member>
        <member name="T:CryptoExchange.Net.CommonObjects.Symbol">
            <summary>
            Symbol data
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.CommonObjects.Symbol.Name">
            <summary>
            Name of the symbol
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.CommonObjects.Symbol.MinTradeQuantity">
            <summary>
            Minimal quantity of an order
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.CommonObjects.Symbol.QuantityStep">
            <summary>
            Step with which the quantity should increase
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.CommonObjects.Symbol.PriceStep">
            <summary>
            step with which the price should increase
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.CommonObjects.Symbol.QuantityDecimals">
            <summary>
            The max amount of decimals for quantity
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.CommonObjects.Symbol.PriceDecimals">
            <summary>
            The max amount of decimal for price
            </summary>
        </member>
        <member name="T:CryptoExchange.Net.CommonObjects.Ticker">
            <summary>
            Ticker data
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.CommonObjects.Ticker.Symbol">
            <summary>
            Symbol
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.CommonObjects.Ticker.Price24H">
            <summary>
            Price 24 hours ago
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.CommonObjects.Ticker.LastPrice">
            <summary>
            Last trade price
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.CommonObjects.Ticker.LowPrice">
            <summary>
            24 hour low price
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.CommonObjects.Ticker.HighPrice">
            <summary>
            24 hour high price
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.CommonObjects.Ticker.Volume">
            <summary>
            24 hour volume
            </summary>
        </member>
        <member name="T:CryptoExchange.Net.CommonObjects.Trade">
            <summary>
            Trade data
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.CommonObjects.Trade.Symbol">
            <summary>
            Symbol of the trade
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.CommonObjects.Trade.Price">
            <summary>
            Price of the trade
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.CommonObjects.Trade.Quantity">
            <summary>
            Quantity of the trade
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.CommonObjects.Trade.Timestamp">
            <summary>
            Timestamp of the trade
            </summary>
        </member>
        <member name="T:CryptoExchange.Net.CommonObjects.UserTrade">
            <summary>
            User trade info
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.CommonObjects.UserTrade.Id">
            <summary>
            Id of the trade
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.CommonObjects.UserTrade.OrderId">
            <summary>
            Order id of the trade
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.CommonObjects.UserTrade.Fee">
            <summary>
            Fee of the trade
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.CommonObjects.UserTrade.FeeAsset">
            <summary>
            The asset the fee is paid in
            </summary>
        </member>
        <member name="T:CryptoExchange.Net.Converters.ArrayPropertyAttribute">
            <summary>
            Mark property as an index in the array
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Converters.ArrayPropertyAttribute.Index">
            <summary>
            The index in the array
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.Converters.ArrayPropertyAttribute.#ctor(System.Int32)">
            <summary>
            ctor
            </summary>
            <param name="index"></param>
        </member>
        <member name="T:CryptoExchange.Net.Converters.JsonNet.ArrayConverter">
            <summary>
            Converter for arrays to objects. Can deserialize data like [0.1, 0.2, "test"] to an object. Mapping is done by marking the class with [JsonConverter(typeof(ArrayConverter))] and the properties
            with [ArrayProperty(x)] where x is the index of the property in the array
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.Converters.JsonNet.ArrayConverter.CanConvert(System.Type)">
            <inheritdoc />
        </member>
        <member name="M:CryptoExchange.Net.Converters.JsonNet.ArrayConverter.ReadJson(Newtonsoft.Json.JsonReader,System.Type,System.Object,Newtonsoft.Json.JsonSerializer)">
            <inheritdoc />
        </member>
        <member name="M:CryptoExchange.Net.Converters.JsonNet.ArrayConverter.WriteJson(Newtonsoft.Json.JsonWriter,System.Object,Newtonsoft.Json.JsonSerializer)">
            <inheritdoc />
        </member>
        <member name="T:CryptoExchange.Net.Converters.JsonNet.BaseConverter`1">
            <summary>
            Base class for enum converters
            </summary>
            <typeparam name="T">Type of enum to convert</typeparam>
        </member>
        <member name="P:CryptoExchange.Net.Converters.JsonNet.BaseConverter`1.Mapping">
            <summary>
            The enum->string mapping
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.Converters.JsonNet.BaseConverter`1.#ctor(System.Boolean)">
            <summary>
            ctor
            </summary>
            <param name="useQuotes"></param>
        </member>
        <member name="M:CryptoExchange.Net.Converters.JsonNet.BaseConverter`1.WriteJson(Newtonsoft.Json.JsonWriter,System.Object,Newtonsoft.Json.JsonSerializer)">
            <inheritdoc />
        </member>
        <member name="M:CryptoExchange.Net.Converters.JsonNet.BaseConverter`1.ReadJson(Newtonsoft.Json.JsonReader,System.Type,System.Object,Newtonsoft.Json.JsonSerializer)">
            <inheritdoc />
        </member>
        <member name="M:CryptoExchange.Net.Converters.JsonNet.BaseConverter`1.ReadString(System.String)">
            <summary>
            Convert a string value
            </summary>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Converters.JsonNet.BaseConverter`1.CanConvert(System.Type)">
            <inheritdoc />
        </member>
        <member name="T:CryptoExchange.Net.Converters.JsonNet.BoolConverter">
            <summary>
            Boolean converter with support for "0"/"1" (strings)
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.Converters.JsonNet.BoolConverter.CanConvert(System.Type)">
            <summary>
            Determines whether this instance can convert the specified object type.
            </summary>
            <param name="objectType">Type of the object.</param>
            <returns>
            <c>true</c> if this instance can convert the specified object type; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:CryptoExchange.Net.Converters.JsonNet.BoolConverter.ReadJson(Newtonsoft.Json.JsonReader,System.Type,System.Object,Newtonsoft.Json.JsonSerializer)">
            <summary>
            Reads the JSON representation of the object.
            </summary>
            <param name="reader">The <see cref="T:Newtonsoft.Json.JsonReader"/> to read from.</param>
            <param name="objectType">Type of the object.</param>
            <param name="existingValue">The existing value of object being read.</param>
            <param name="serializer">The calling serializer.</param>
            <returns>
            The object value.
            </returns>
        </member>
        <member name="P:CryptoExchange.Net.Converters.JsonNet.BoolConverter.CanWrite">
            <summary>
            Specifies that this converter will not participate in writing results.
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.Converters.JsonNet.BoolConverter.WriteJson(Newtonsoft.Json.JsonWriter,System.Object,Newtonsoft.Json.JsonSerializer)">
            <summary>
            Writes the JSON representation of the object.
            </summary>
            <param name="writer">The <see cref="T:Newtonsoft.Json.JsonWriter"/> to write to.</param><param name="value">The value.</param><param name="serializer">The calling serializer.</param>
        </member>
        <member name="T:CryptoExchange.Net.Converters.JsonNet.DateTimeConverter">
            <summary>
            Datetime converter. Supports converting from string/long/double to DateTime and back. Numbers are assumed to be the time since 1970-01-01.
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.Converters.JsonNet.DateTimeConverter.CanConvert(System.Type)">
            <inheritdoc />
        </member>
        <member name="M:CryptoExchange.Net.Converters.JsonNet.DateTimeConverter.ReadJson(Newtonsoft.Json.JsonReader,System.Type,System.Object,Newtonsoft.Json.JsonSerializer)">
            <inheritdoc />
        </member>
        <member name="M:CryptoExchange.Net.Converters.JsonNet.DateTimeConverter.ParseFromLong(System.Int64)">
            <summary>
            Parse a long value to datetime
            </summary>
            <param name="longValue"></param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Converters.JsonNet.DateTimeConverter.ParseFromString(System.String)">
            <summary>
            Parse a string value to datetime
            </summary>
            <param name="stringValue"></param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Converters.JsonNet.DateTimeConverter.ConvertFromSeconds(System.Double)">
            <summary>
            Convert a seconds since epoch (01-01-1970) value to DateTime
            </summary>
            <param name="seconds"></param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Converters.JsonNet.DateTimeConverter.ConvertFromMilliseconds(System.Double)">
            <summary>
            Convert a milliseconds since epoch (01-01-1970) value to DateTime
            </summary>
            <param name="milliseconds"></param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Converters.JsonNet.DateTimeConverter.ConvertFromMicroseconds(System.Int64)">
            <summary>
            Convert a microseconds since epoch (01-01-1970) value to DateTime
            </summary>
            <param name="microseconds"></param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Converters.JsonNet.DateTimeConverter.ConvertFromNanoseconds(System.Int64)">
            <summary>
            Convert a nanoseconds since epoch (01-01-1970) value to DateTime
            </summary>
            <param name="nanoseconds"></param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Converters.JsonNet.DateTimeConverter.ConvertToSeconds(System.Nullable{System.DateTime})">
            <summary>
            Convert a DateTime value to seconds since epoch (01-01-1970) value
            </summary>
            <param name="time"></param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Converters.JsonNet.DateTimeConverter.ConvertToMilliseconds(System.Nullable{System.DateTime})">
            <summary>
            Convert a DateTime value to milliseconds since epoch (01-01-1970) value
            </summary>
            <param name="time"></param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Converters.JsonNet.DateTimeConverter.ConvertToMicroseconds(System.Nullable{System.DateTime})">
            <summary>
            Convert a DateTime value to microseconds since epoch (01-01-1970) value
            </summary>
            <param name="time"></param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Converters.JsonNet.DateTimeConverter.ConvertToNanoseconds(System.Nullable{System.DateTime})">
            <summary>
            Convert a DateTime value to nanoseconds since epoch (01-01-1970) value
            </summary>
            <param name="time"></param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Converters.JsonNet.DateTimeConverter.WriteJson(Newtonsoft.Json.JsonWriter,System.Object,Newtonsoft.Json.JsonSerializer)">
            <inheritdoc />
        </member>
        <member name="T:CryptoExchange.Net.Converters.JsonNet.DecimalStringWriterConverter">
            <summary>
            Converter for serializing decimal values as string
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Converters.JsonNet.DecimalStringWriterConverter.CanRead">
            <inheritdoc />
        </member>
        <member name="M:CryptoExchange.Net.Converters.JsonNet.DecimalStringWriterConverter.CanConvert(System.Type)">
            <inheritdoc />
        </member>
        <member name="M:CryptoExchange.Net.Converters.JsonNet.DecimalStringWriterConverter.ReadJson(Newtonsoft.Json.JsonReader,System.Type,System.Object,Newtonsoft.Json.JsonSerializer)">
            <inheritdoc />
        </member>
        <member name="M:CryptoExchange.Net.Converters.JsonNet.DecimalStringWriterConverter.WriteJson(Newtonsoft.Json.JsonWriter,System.Object,Newtonsoft.Json.JsonSerializer)">
            <inheritdoc />
        </member>
        <member name="T:CryptoExchange.Net.Converters.JsonNet.EnumConverter">
            <summary>
            Converter for enum values. Enums entries should be noted with a MapAttribute to map the enum value to a string value
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.Converters.JsonNet.EnumConverter.#ctor">
            <summary>
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.Converters.JsonNet.EnumConverter.#ctor(System.Boolean,System.Boolean)">
            <summary>
            </summary>
            <param name="writeAsInt"></param>
            <param name="warnOnMissingEntry"></param>
        </member>
        <member name="M:CryptoExchange.Net.Converters.JsonNet.EnumConverter.CanConvert(System.Type)">
            <inheritdoc />
        </member>
        <member name="M:CryptoExchange.Net.Converters.JsonNet.EnumConverter.ReadJson(Newtonsoft.Json.JsonReader,System.Type,System.Object,Newtonsoft.Json.JsonSerializer)">
            <inheritdoc />
        </member>
        <member name="M:CryptoExchange.Net.Converters.JsonNet.EnumConverter.GetString``1(``0)">
            <summary>
            Get the string value for an enum value using the MapAttribute mapping. When multiple values are mapped for a enum entry the first value will be returned
            </summary>
            <typeparam name="T"></typeparam>
            <param name="enumValue"></param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Converters.JsonNet.EnumConverter.WriteJson(Newtonsoft.Json.JsonWriter,System.Object,Newtonsoft.Json.JsonSerializer)">
            <inheritdoc />
        </member>
        <member name="T:CryptoExchange.Net.Converters.JsonNet.JsonNetMessageAccessor">
            <summary>
            Json.Net message accessor
            </summary>
        </member>
        <member name="F:CryptoExchange.Net.Converters.JsonNet.JsonNetMessageAccessor._token">
            <summary>
            The json token loaded
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Converters.JsonNet.JsonNetMessageAccessor.IsJson">
            <inheritdoc />
        </member>
        <member name="P:CryptoExchange.Net.Converters.JsonNet.JsonNetMessageAccessor.OriginalDataAvailable">
            <inheritdoc />
        </member>
        <member name="P:CryptoExchange.Net.Converters.JsonNet.JsonNetMessageAccessor.Underlying">
            <inheritdoc />
        </member>
        <member name="M:CryptoExchange.Net.Converters.JsonNet.JsonNetMessageAccessor.Deserialize(System.Type,System.Nullable{CryptoExchange.Net.Converters.MessageParsing.MessagePath})">
            <inheritdoc />
        </member>
        <member name="M:CryptoExchange.Net.Converters.JsonNet.JsonNetMessageAccessor.Deserialize``1(System.Nullable{CryptoExchange.Net.Converters.MessageParsing.MessagePath})">
            <inheritdoc />
        </member>
        <member name="M:CryptoExchange.Net.Converters.JsonNet.JsonNetMessageAccessor.GetNodeType">
            <inheritdoc />
        </member>
        <member name="M:CryptoExchange.Net.Converters.JsonNet.JsonNetMessageAccessor.GetNodeType(CryptoExchange.Net.Converters.MessageParsing.MessagePath)">
            <inheritdoc />
        </member>
        <member name="M:CryptoExchange.Net.Converters.JsonNet.JsonNetMessageAccessor.GetValue``1(CryptoExchange.Net.Converters.MessageParsing.MessagePath)">
            <inheritdoc />
        </member>
        <member name="M:CryptoExchange.Net.Converters.JsonNet.JsonNetMessageAccessor.GetValues``1(CryptoExchange.Net.Converters.MessageParsing.MessagePath)">
            <inheritdoc />
        </member>
        <member name="M:CryptoExchange.Net.Converters.JsonNet.JsonNetMessageAccessor.GetOriginalString">
            <inheritdoc />
        </member>
        <member name="M:CryptoExchange.Net.Converters.JsonNet.JsonNetMessageAccessor.Clear">
            <inheritdoc />
        </member>
        <member name="T:CryptoExchange.Net.Converters.JsonNet.JsonNetStreamMessageAccessor">
            <summary>
            Json.Net stream message accessor
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Converters.JsonNet.JsonNetStreamMessageAccessor.OriginalDataAvailable">
            <inheritdoc />
        </member>
        <member name="M:CryptoExchange.Net.Converters.JsonNet.JsonNetStreamMessageAccessor.Read(System.IO.Stream,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:CryptoExchange.Net.Converters.JsonNet.JsonNetStreamMessageAccessor.GetOriginalString">
            <inheritdoc />
        </member>
        <member name="M:CryptoExchange.Net.Converters.JsonNet.JsonNetStreamMessageAccessor.Clear">
            <inheritdoc />
        </member>
        <member name="T:CryptoExchange.Net.Converters.JsonNet.JsonNetByteMessageAccessor">
            <summary>
            Json.Net byte message accessor
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.Converters.JsonNet.JsonNetByteMessageAccessor.Read(System.ReadOnlyMemory{System.Byte})">
            <inheritdoc />
        </member>
        <member name="M:CryptoExchange.Net.Converters.JsonNet.JsonNetByteMessageAccessor.GetOriginalString">
            <inheritdoc />
        </member>
        <member name="P:CryptoExchange.Net.Converters.JsonNet.JsonNetByteMessageAccessor.OriginalDataAvailable">
            <inheritdoc />
        </member>
        <member name="M:CryptoExchange.Net.Converters.JsonNet.JsonNetByteMessageAccessor.Clear">
            <inheritdoc />
        </member>
        <member name="T:CryptoExchange.Net.Converters.JsonNet.JsonNetMessageSerializer">
            <inheritdoc />
        </member>
        <member name="M:CryptoExchange.Net.Converters.JsonNet.JsonNetMessageSerializer.Serialize(System.Object)">
            <inheritdoc />
        </member>
        <member name="T:CryptoExchange.Net.Converters.JsonNet.SerializerOptions">
            <summary>
            Serializer options
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Converters.JsonNet.SerializerOptions.WithConverters">
            <summary>
            Json serializer settings which includes the EnumConverter, DateTimeConverter and BoolConverter
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Converters.JsonNet.SerializerOptions.Default">
            <summary>
            Default json serializer settings
            </summary>
        </member>
        <member name="T:CryptoExchange.Net.Converters.MessageParsing.NodeAccessor">
            <summary>
            Node accessor
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Converters.MessageParsing.NodeAccessor.Index">
            <summary>
            Index
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Converters.MessageParsing.NodeAccessor.Property">
            <summary>
            Property name
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Converters.MessageParsing.NodeAccessor.Type">
            <summary>
            Type (0 = int, 1 = string, 2 = prop name)
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.Converters.MessageParsing.NodeAccessor.Int(System.Int32)">
            <summary>
            Create an int node accessor
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Converters.MessageParsing.NodeAccessor.String(System.String)">
            <summary>
            Create a string node accessor
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Converters.MessageParsing.NodeAccessor.PropertyName">
            <summary>
            Create a property name node accessor
            </summary>
            <returns></returns>
        </member>
        <member name="T:CryptoExchange.Net.Converters.MessageParsing.MessagePath">
            <summary>
            Message access definition
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.Converters.MessageParsing.MessagePath.#ctor">
            <summary>
            ctor
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.Converters.MessageParsing.MessagePath.Get">
            <summary>
            Create a new message path
            </summary>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Converters.MessageParsing.MessagePath.GetEnumerator">
            <summary>
            IEnumerable implementation
            </summary>
            <returns></returns>
        </member>
        <member name="T:CryptoExchange.Net.Converters.MessageParsing.MessagePathExtension">
            <summary>
            Message path extension methods
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.Converters.MessageParsing.MessagePathExtension.Property(CryptoExchange.Net.Converters.MessageParsing.MessagePath,System.String)">
            <summary>
            Add a string node accessor
            </summary>
            <param name="path"></param>
            <param name="propName"></param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Converters.MessageParsing.MessagePathExtension.PropertyName(CryptoExchange.Net.Converters.MessageParsing.MessagePath)">
            <summary>
            Add a property name node accessor
            </summary>
            <param name="path"></param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Converters.MessageParsing.MessagePathExtension.Index(CryptoExchange.Net.Converters.MessageParsing.MessagePath,System.Int32)">
            <summary>
            Add a int node accessor
            </summary>
            <param name="path"></param>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="T:CryptoExchange.Net.Converters.MessageParsing.NodeType">
            <summary>
            Message node type
            </summary>
        </member>
        <member name="F:CryptoExchange.Net.Converters.MessageParsing.NodeType.Array">
            <summary>
            Array node
            </summary>
        </member>
        <member name="F:CryptoExchange.Net.Converters.MessageParsing.NodeType.Object">
            <summary>
            Object node
            </summary>
        </member>
        <member name="F:CryptoExchange.Net.Converters.MessageParsing.NodeType.Value">
            <summary>
            Value node
            </summary>
        </member>
        <member name="T:CryptoExchange.Net.Converters.SystemTextJson.ArrayConverter">
            <summary>
            Converter for arrays to objects. Can deserialize data like [0.1, 0.2, "test"] to an object. Mapping is done by marking the class with [JsonConverter(typeof(ArrayConverter))] and the properties
            with [ArrayProperty(x)] where x is the index of the property in the array
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.Converters.SystemTextJson.ArrayConverter.CanConvert(System.Type)">
            <inheritdoc />
        </member>
        <member name="M:CryptoExchange.Net.Converters.SystemTextJson.ArrayConverter.CreateConverter(System.Type,System.Text.Json.JsonSerializerOptions)">
            <inheritdoc />
        </member>
        <member name="M:CryptoExchange.Net.Converters.SystemTextJson.ArrayConverter.ArrayConverterInner`1.Read(System.Text.Json.Utf8JsonReader@,System.Type,System.Text.Json.JsonSerializerOptions)">
            <inheritdoc />
        </member>
        <member name="T:CryptoExchange.Net.Converters.SystemTextJson.BoolConverter">
            <summary>
            Bool converter
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.Converters.SystemTextJson.BoolConverter.CanConvert(System.Type)">
            <inheritdoc />
        </member>
        <member name="M:CryptoExchange.Net.Converters.SystemTextJson.BoolConverter.CreateConverter(System.Type,System.Text.Json.JsonSerializerOptions)">
            <inheritdoc />
        </member>
        <member name="T:CryptoExchange.Net.Converters.SystemTextJson.DateTimeConverter">
            <summary>
            Date time converter
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.Converters.SystemTextJson.DateTimeConverter.CanConvert(System.Type)">
            <inheritdoc />
        </member>
        <member name="M:CryptoExchange.Net.Converters.SystemTextJson.DateTimeConverter.CreateConverter(System.Type,System.Text.Json.JsonSerializerOptions)">
            <inheritdoc />
        </member>
        <member name="M:CryptoExchange.Net.Converters.SystemTextJson.DateTimeConverter.ParseFromDouble(System.Double)">
            <summary>
            Parse a long value to datetime
            </summary>
            <param name="longValue"></param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Converters.SystemTextJson.DateTimeConverter.ParseFromString(System.String)">
            <summary>
            Parse a string value to datetime
            </summary>
            <param name="stringValue"></param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Converters.SystemTextJson.DateTimeConverter.ConvertFromSeconds(System.Double)">
            <summary>
            Convert a seconds since epoch (01-01-1970) value to DateTime
            </summary>
            <param name="seconds"></param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Converters.SystemTextJson.DateTimeConverter.ConvertFromMilliseconds(System.Double)">
            <summary>
            Convert a milliseconds since epoch (01-01-1970) value to DateTime
            </summary>
            <param name="milliseconds"></param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Converters.SystemTextJson.DateTimeConverter.ConvertFromMicroseconds(System.Double)">
            <summary>
            Convert a microseconds since epoch (01-01-1970) value to DateTime
            </summary>
            <param name="microseconds"></param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Converters.SystemTextJson.DateTimeConverter.ConvertFromNanoseconds(System.Double)">
            <summary>
            Convert a nanoseconds since epoch (01-01-1970) value to DateTime
            </summary>
            <param name="nanoseconds"></param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Converters.SystemTextJson.DateTimeConverter.ConvertToSeconds(System.Nullable{System.DateTime})">
            <summary>
            Convert a DateTime value to seconds since epoch (01-01-1970) value
            </summary>
            <param name="time"></param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Converters.SystemTextJson.DateTimeConverter.ConvertToMilliseconds(System.Nullable{System.DateTime})">
            <summary>
            Convert a DateTime value to milliseconds since epoch (01-01-1970) value
            </summary>
            <param name="time"></param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Converters.SystemTextJson.DateTimeConverter.ConvertToMicroseconds(System.Nullable{System.DateTime})">
            <summary>
            Convert a DateTime value to microseconds since epoch (01-01-1970) value
            </summary>
            <param name="time"></param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Converters.SystemTextJson.DateTimeConverter.ConvertToNanoseconds(System.Nullable{System.DateTime})">
            <summary>
            Convert a DateTime value to nanoseconds since epoch (01-01-1970) value
            </summary>
            <param name="time"></param>
            <returns></returns>
        </member>
        <member name="T:CryptoExchange.Net.Converters.SystemTextJson.DecimalConverter">
            <summary>
            Decimal converter
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.Converters.SystemTextJson.DecimalConverter.Read(System.Text.Json.Utf8JsonReader@,System.Type,System.Text.Json.JsonSerializerOptions)">
            <inheritdoc />
        </member>
        <member name="M:CryptoExchange.Net.Converters.SystemTextJson.DecimalConverter.Write(System.Text.Json.Utf8JsonWriter,System.Nullable{System.Decimal},System.Text.Json.JsonSerializerOptions)">
            <inheritdoc />
        </member>
        <member name="T:CryptoExchange.Net.Converters.SystemTextJson.DecimalStringWriterConverter">
            <summary>
            Converter for serializing decimal values as string
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.Converters.SystemTextJson.DecimalStringWriterConverter.Read(System.Text.Json.Utf8JsonReader@,System.Type,System.Text.Json.JsonSerializerOptions)">
            <inheritdoc />
        </member>
        <member name="M:CryptoExchange.Net.Converters.SystemTextJson.DecimalStringWriterConverter.Write(System.Text.Json.Utf8JsonWriter,System.Decimal,System.Text.Json.JsonSerializerOptions)">
            <inheritdoc />
        </member>
        <member name="T:CryptoExchange.Net.Converters.SystemTextJson.EnumConverter">
            <summary>
            Converter for enum values. Enums entries should be noted with a MapAttribute to map the enum value to a string value
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.Converters.SystemTextJson.EnumConverter.#ctor">
            <summary>
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.Converters.SystemTextJson.EnumConverter.#ctor(System.Boolean,System.Boolean)">
            <summary>
            </summary>
            <param name="writeAsInt"></param>
            <param name="warnOnMissingEntry"></param>
        </member>
        <member name="M:CryptoExchange.Net.Converters.SystemTextJson.EnumConverter.CanConvert(System.Type)">
            <inheritdoc />
        </member>
        <member name="M:CryptoExchange.Net.Converters.SystemTextJson.EnumConverter.CreateConverter(System.Type,System.Text.Json.JsonSerializerOptions)">
            <inheritdoc />
        </member>
        <member name="M:CryptoExchange.Net.Converters.SystemTextJson.EnumConverter.GetString``1(``0)">
            <summary>
            Get the string value for an enum value using the MapAttribute mapping. When multiple values are mapped for a enum entry the first value will be returned
            </summary>
            <typeparam name="T"></typeparam>
            <param name="enumValue"></param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Converters.SystemTextJson.EnumConverter.GetString(System.Type,System.Object)">
            <summary>
            Get the string value for an enum value using the MapAttribute mapping. When multiple values are mapped for a enum entry the first value will be returned
            </summary>
            <param name="objectType"></param>
            <param name="enumValue"></param>
            <returns></returns>
        </member>
        <member name="T:CryptoExchange.Net.Converters.SystemTextJson.SerializerOptions">
            <summary>
            Serializer options
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Converters.SystemTextJson.SerializerOptions.WithConverters">
            <summary>
            Json serializer settings which includes the EnumConverter, DateTimeConverter, BoolConverter and DecimalConverter
            </summary>
        </member>
        <member name="T:CryptoExchange.Net.Converters.SystemTextJson.SystemTextJsonMessageAccessor">
            <summary>
            System.Text.Json message accessor
            </summary>
        </member>
        <member name="F:CryptoExchange.Net.Converters.SystemTextJson.SystemTextJsonMessageAccessor._document">
            <summary>
            The JsonDocument loaded
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Converters.SystemTextJson.SystemTextJsonMessageAccessor.IsJson">
            <inheritdoc />
        </member>
        <member name="P:CryptoExchange.Net.Converters.SystemTextJson.SystemTextJsonMessageAccessor.OriginalDataAvailable">
            <inheritdoc />
        </member>
        <member name="P:CryptoExchange.Net.Converters.SystemTextJson.SystemTextJsonMessageAccessor.Underlying">
            <inheritdoc />
        </member>
        <member name="M:CryptoExchange.Net.Converters.SystemTextJson.SystemTextJsonMessageAccessor.Deserialize(System.Type,System.Nullable{CryptoExchange.Net.Converters.MessageParsing.MessagePath})">
            <inheritdoc />
        </member>
        <member name="M:CryptoExchange.Net.Converters.SystemTextJson.SystemTextJsonMessageAccessor.Deserialize``1(System.Nullable{CryptoExchange.Net.Converters.MessageParsing.MessagePath})">
            <inheritdoc />
        </member>
        <member name="M:CryptoExchange.Net.Converters.SystemTextJson.SystemTextJsonMessageAccessor.GetNodeType">
            <inheritdoc />
        </member>
        <member name="M:CryptoExchange.Net.Converters.SystemTextJson.SystemTextJsonMessageAccessor.GetNodeType(CryptoExchange.Net.Converters.MessageParsing.MessagePath)">
            <inheritdoc />
        </member>
        <member name="M:CryptoExchange.Net.Converters.SystemTextJson.SystemTextJsonMessageAccessor.GetValue``1(CryptoExchange.Net.Converters.MessageParsing.MessagePath)">
            <inheritdoc />
        </member>
        <member name="M:CryptoExchange.Net.Converters.SystemTextJson.SystemTextJsonMessageAccessor.GetValues``1(CryptoExchange.Net.Converters.MessageParsing.MessagePath)">
            <inheritdoc />
        </member>
        <member name="M:CryptoExchange.Net.Converters.SystemTextJson.SystemTextJsonMessageAccessor.GetOriginalString">
            <inheritdoc />
        </member>
        <member name="M:CryptoExchange.Net.Converters.SystemTextJson.SystemTextJsonMessageAccessor.Clear">
            <inheritdoc />
        </member>
        <member name="T:CryptoExchange.Net.Converters.SystemTextJson.SystemTextJsonStreamMessageAccessor">
            <summary>
            System.Text.Json stream message accessor
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Converters.SystemTextJson.SystemTextJsonStreamMessageAccessor.OriginalDataAvailable">
            <inheritdoc />
        </member>
        <member name="M:CryptoExchange.Net.Converters.SystemTextJson.SystemTextJsonStreamMessageAccessor.Read(System.IO.Stream,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:CryptoExchange.Net.Converters.SystemTextJson.SystemTextJsonStreamMessageAccessor.GetOriginalString">
            <inheritdoc />
        </member>
        <member name="M:CryptoExchange.Net.Converters.SystemTextJson.SystemTextJsonStreamMessageAccessor.Clear">
            <inheritdoc />
        </member>
        <member name="T:CryptoExchange.Net.Converters.SystemTextJson.SystemTextJsonByteMessageAccessor">
            <summary>
            System.Text.Json byte message accessor
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.Converters.SystemTextJson.SystemTextJsonByteMessageAccessor.Read(System.ReadOnlyMemory{System.Byte})">
            <inheritdoc />
        </member>
        <member name="M:CryptoExchange.Net.Converters.SystemTextJson.SystemTextJsonByteMessageAccessor.GetOriginalString">
            <inheritdoc />
        </member>
        <member name="P:CryptoExchange.Net.Converters.SystemTextJson.SystemTextJsonByteMessageAccessor.OriginalDataAvailable">
            <inheritdoc />
        </member>
        <member name="M:CryptoExchange.Net.Converters.SystemTextJson.SystemTextJsonByteMessageAccessor.Clear">
            <inheritdoc />
        </member>
        <member name="T:CryptoExchange.Net.Converters.SystemTextJson.SystemTextJsonMessageSerializer">
            <inheritdoc />
        </member>
        <member name="M:CryptoExchange.Net.Converters.SystemTextJson.SystemTextJsonMessageSerializer.Serialize(System.Object)">
            <inheritdoc />
        </member>
        <member name="T:CryptoExchange.Net.ExchangeHelpers">
            <summary>
            General helpers functions
            </summary>
        </member>
        <member name="F:CryptoExchange.Net.ExchangeHelpers._lastId">
            <summary>
            The last used id, use NextId() to get the next id and up this
            </summary>
        </member>
        <member name="F:CryptoExchange.Net.ExchangeHelpers._idLock">
            <summary>
            Lock for id generating
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.ExchangeHelpers.ClampValue(System.Decimal,System.Decimal,System.Decimal)">
            <summary>
            Clamp a value between a min and max
            </summary>
            <param name="min"></param>
            <param name="max"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.ExchangeHelpers.AdjustValueStep(System.Decimal,System.Decimal,System.Nullable{System.Decimal},CryptoExchange.Net.Objects.RoundingType,System.Decimal)">
            <summary>
            Adjust a value to be between the min and max parameters and rounded to the closest step.
            </summary>
            <param name="min">The min value</param>
            <param name="max">The max value</param>
            <param name="step">The step size the value should be floored to. For example, value 2.548 with a step size of 0.01 will output 2.54</param>
            <param name="roundingType">How to round</param>
            <param name="value">The input value</param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.ExchangeHelpers.AdjustValuePrecision(System.Decimal,System.Decimal,System.Nullable{System.Int32},CryptoExchange.Net.Objects.RoundingType,System.Decimal)">
            <summary>
            Adjust a value to be between the min and max parameters and rounded to the closest precision.
            </summary>
            <param name="min">The min value</param>
            <param name="max">The max value</param>
            <param name="precision">The precision the value should be rounded to. For example, value 2.554215 with a precision of 5 will output 2.5542</param>
            <param name="roundingType">How to round</param>
            <param name="value">The input value</param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.ExchangeHelpers.RoundToSignificantDigits(System.Decimal,System.Int32,CryptoExchange.Net.Objects.RoundingType)">
            <summary>
            Round a value to have the provided total number of digits. For example, value 253.12332 with 5 digits would be 253.12 
            </summary>
            <param name="value">The value to round</param>
            <param name="digits">The total amount of digits (NOT decimal places) to round to</param>
            <param name="roundingType">How to round</param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.ExchangeHelpers.RoundDown(System.Decimal,System.Double)">
            <summary>
            Rounds a value down to 
            </summary>
            <param name="i"></param>
            <param name="decimalPlaces"></param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.ExchangeHelpers.Normalize(System.Decimal)">
            <summary>
            Strips any trailing zero's of a decimal value, useful when converting the value to string.
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.ExchangeHelpers.NextId">
            <summary>
            Generate a new unique id. The id is staticly stored so it is guarenteed to be unique
            </summary>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.ExchangeHelpers.LastId">
            <summary>
            Return the last unique id that was generated
            </summary>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.ExchangeHelpers.RandomString(System.Int32)">
            <summary>
            Generate a random string of specified length
            </summary>
            <param name="length">Length of the random string</param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.ExchangeHelpers.AppendRandomString(System.String,System.Int32)">
            <summary>
            Generate a random string of specified length
            </summary>
            <param name="source">The initial string</param>
            <param name="totalLength">Total length of the resulting string</param>
            <returns></returns>
        </member>
        <member name="T:CryptoExchange.Net.ExtensionMethods">
            <summary>
            Helper methods
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.ExtensionMethods.AddParameter(System.Collections.Generic.Dictionary{System.String,System.Object},System.String,System.String)">
            <summary>
            Add a parameter
            </summary>
            <param name="parameters"></param>
            <param name="key"></param>
            <param name="value"></param>
        </member>
        <member name="M:CryptoExchange.Net.ExtensionMethods.AddParameter(System.Collections.Generic.Dictionary{System.String,System.Object},System.String,System.Object)">
            <summary>
            Add a parameter
            </summary>
            <param name="parameters"></param>
            <param name="key"></param>
            <param name="value"></param>
        </member>
        <member name="M:CryptoExchange.Net.ExtensionMethods.AddOptionalParameter(System.Collections.Generic.Dictionary{System.String,System.Object},System.String,System.Object)">
            <summary>
            Add an optional parameter. Not added if value is null
            </summary>
            <param name="parameters"></param>
            <param name="key"></param>
            <param name="value"></param>
        </member>
        <member name="M:CryptoExchange.Net.ExtensionMethods.CreateParamString(System.Collections.Generic.IDictionary{System.String,System.Object},System.Boolean,CryptoExchange.Net.Objects.ArrayParametersSerialization)">
            <summary>
            Create a query string of the specified parameters
            </summary>
            <param name="parameters">The parameters to use</param>
            <param name="urlEncodeValues">Whether or not the values should be url encoded</param>
            <param name="serializationType">How to serialize array parameters</param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.ExtensionMethods.ToFormData(System.Collections.Generic.IDictionary{System.String,System.Object})">
            <summary>
            Convert a dictionary to formdata string
            </summary>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.ExtensionMethods.GetString(System.Security.SecureString)">
            <summary>
            Get the string the secure string is representing
            </summary>
            <param name="source">The source secure string</param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.ExtensionMethods.IsEqualTo(System.Security.SecureString,System.Security.SecureString)">
            <summary>
            Are 2 secure strings equal
            </summary>
            <param name="ss1">Source secure string</param>
            <param name="ss2">Compare secure string</param>
            <returns>True if equal by value</returns>
        </member>
        <member name="M:CryptoExchange.Net.ExtensionMethods.ToSecureString(System.String)">
            <summary>
            Create a secure string from a string
            </summary>
            <param name="source"></param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.ExtensionMethods.ValidateIntValues(System.Int32,System.String,System.Int32[])">
            <summary>
            Validates an int is one of the allowed values
            </summary>
            <param name="value">Value of the int</param>
            <param name="argumentName">Name of the parameter</param>
            <param name="allowedValues">Allowed values</param>
        </member>
        <member name="M:CryptoExchange.Net.ExtensionMethods.ValidateIntBetween(System.Int32,System.String,System.Int32,System.Int32)">
            <summary>
            Validates an int is between two values
            </summary>
            <param name="value">The value of the int</param>
            <param name="argumentName">Name of the parameter</param>
            <param name="minValue">Min value</param>
            <param name="maxValue">Max value</param>
        </member>
        <member name="M:CryptoExchange.Net.ExtensionMethods.ValidateNotNull(System.String,System.String)">
            <summary>
            Validates a string is not null or empty
            </summary>
            <param name="value">The value of the string</param>
            <param name="argumentName">Name of the parameter</param>
        </member>
        <member name="M:CryptoExchange.Net.ExtensionMethods.ValidateNullOrNotEmpty(System.String,System.String)">
            <summary>
            Validates a string is null or not empty
            </summary>
            <param name="value"></param>
            <param name="argumentName"></param>
        </member>
        <member name="M:CryptoExchange.Net.ExtensionMethods.ValidateNotNull(System.Object,System.String)">
            <summary>
            Validates an object is not null
            </summary>
            <param name="value">The value of the object</param>
            <param name="argumentName">Name of the parameter</param>
        </member>
        <member name="M:CryptoExchange.Net.ExtensionMethods.ValidateNotNull``1(System.Collections.Generic.IEnumerable{``0},System.String)">
            <summary>
            Validates a list is not null or empty
            </summary>
            <param name="value">The value of the object</param>
            <param name="argumentName">Name of the parameter</param>
        </member>
        <member name="M:CryptoExchange.Net.ExtensionMethods.ToLogString(System.Exception)">
            <summary>
            Format an exception and inner exception to a readable string
            </summary>
            <param name="exception"></param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.ExtensionMethods.AppendPath(System.String,System.String[])">
            <summary>
            Append a base url with provided path
            </summary>
            <param name="url"></param>
            <param name="path"></param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.ExtensionMethods.FillPathParameters(System.String,System.String[])">
            <summary>
            Fill parameters in a path. Parameters are specified by '{}' and should be specified in occuring sequence
            </summary>
            <param name="path">The total path string</param>
            <param name="values">The values to fill</param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.ExtensionMethods.SetParameters(System.Uri,System.Collections.Generic.IDictionary{System.String,System.Object},CryptoExchange.Net.Objects.ArrayParametersSerialization)">
            <summary>
            Create a new uri with the provided parameters as query
            </summary>
            <param name="parameters"></param>
            <param name="baseUri"></param>
            <param name="arraySerialization"></param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.ExtensionMethods.SetParameters(System.Uri,System.Linq.IOrderedEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.Object}},CryptoExchange.Net.Objects.ArrayParametersSerialization)">
            <summary>
            Create a new uri with the provided parameters as query
            </summary>
            <param name="parameters"></param>
            <param name="baseUri"></param>
            <param name="arraySerialization"></param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.ExtensionMethods.AddQueryParmeter(System.Uri,System.String,System.String)">
            <summary>
            Add parameter to URI
            </summary>
            <param name="uri"></param>
            <param name="name"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.ExtensionMethods.DecompressGzip(System.ReadOnlyMemory{System.Byte})">
            <summary>
            Decompress using Gzip
            </summary>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="T:CryptoExchange.Net.Interfaces.CommonClients.IBaseRestClient">
            <summary>
            Common rest client endpoints
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Interfaces.CommonClients.IBaseRestClient.ExchangeName">
            <summary>
            The name of the exchange
            </summary>
        </member>
        <member name="E:CryptoExchange.Net.Interfaces.CommonClients.IBaseRestClient.OnOrderPlaced">
            <summary>
            Should be triggered on order placing
            </summary>
        </member>
        <member name="E:CryptoExchange.Net.Interfaces.CommonClients.IBaseRestClient.OnOrderCanceled">
            <summary>
            Should be triggered on order cancelling
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.Interfaces.CommonClients.IBaseRestClient.GetSymbolName(System.String,System.String)">
            <summary>
            Get the symbol name based on a base and quote asset
            </summary>
            <param name="baseAsset">The base asset</param>
            <param name="quoteAsset">The quote asset</param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Interfaces.CommonClients.IBaseRestClient.GetSymbolsAsync(System.Threading.CancellationToken)">
            <summary>
            Get a list of symbols for the exchange
            </summary>
            <param name="ct">[Optional] Cancellation token for cancelling the request</param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Interfaces.CommonClients.IBaseRestClient.GetTickerAsync(System.String,System.Threading.CancellationToken)">
            <summary>
            Get a ticker for the exchange
            </summary>
            <param name="symbol">The symbol to get klines for</param>
            <param name="ct">[Optional] Cancellation token for cancelling the request</param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Interfaces.CommonClients.IBaseRestClient.GetTickersAsync(System.Threading.CancellationToken)">
            <summary>
            Get a list of tickers for the exchange
            </summary>
            <param name="ct">[Optional] Cancellation token for cancelling the request</param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Interfaces.CommonClients.IBaseRestClient.GetKlinesAsync(System.String,System.TimeSpan,System.Nullable{System.DateTime},System.Nullable{System.DateTime},System.Nullable{System.Int32},System.Threading.CancellationToken)">
            <summary>
            Get a list of candles for a given symbol on the exchange
            </summary>
            <param name="symbol">The symbol to retrieve the candles for</param>
            <param name="timespan">The timespan to retrieve the candles for. The supported value are dependent on the exchange</param>
            <param name="startTime">[Optional] Start time to retrieve klines for</param>
            <param name="endTime">[Optional] End time to retrieve klines for</param>
            <param name="limit">[Optional] Max number of results</param>
            <param name="ct">[Optional] Cancellation token for cancelling the request</param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Interfaces.CommonClients.IBaseRestClient.GetOrderBookAsync(System.String,System.Threading.CancellationToken)">
            <summary>
            Get the order book for a symbol
            </summary>
            <param name="symbol">The symbol to get the book for</param>
            <param name="ct">[Optional] Cancellation token for cancelling the request</param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Interfaces.CommonClients.IBaseRestClient.GetRecentTradesAsync(System.String,System.Threading.CancellationToken)">
            <summary>
            The recent trades for a symbol
            </summary>
            <param name="symbol">The symbol to get the trades for</param>
            <param name="ct">[Optional] Cancellation token for cancelling the request</param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Interfaces.CommonClients.IBaseRestClient.GetBalancesAsync(System.String,System.Threading.CancellationToken)">
            <summary>
            Get balances
            </summary>
            <param name="accountId">[Optional] The account id to retrieve balances for, required for some exchanges, ignored otherwise</param>
            <param name="ct">[Optional] Cancellation token for cancelling the request</param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Interfaces.CommonClients.IBaseRestClient.GetOrderAsync(System.String,System.String,System.Threading.CancellationToken)">
            <summary>
            Get an order by id
            </summary>
            <param name="orderId">The id</param>
            <param name="symbol">[Optional] The symbol the order is on, required for some exchanges, ignored otherwise</param>
            <param name="ct">[Optional] Cancellation token for cancelling the request</param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Interfaces.CommonClients.IBaseRestClient.GetOrderTradesAsync(System.String,System.String,System.Threading.CancellationToken)">
            <summary>
            Get trades for an order by id
            </summary>
            <param name="orderId">The id</param>
            <param name="symbol">[Optional] The symbol the order is on, required for some exchanges, ignored otherwise</param>
            <param name="ct">[Optional] Cancellation token for cancelling the request</param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Interfaces.CommonClients.IBaseRestClient.GetOpenOrdersAsync(System.String,System.Threading.CancellationToken)">
            <summary>
            Get a list of open orders
            </summary>
            <param name="symbol">[Optional] The symbol to get open orders for, required for some exchanges, ignored otherwise</param>
            <param name="ct">[Optional] Cancellation token for cancelling the request</param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Interfaces.CommonClients.IBaseRestClient.GetClosedOrdersAsync(System.String,System.Threading.CancellationToken)">
            <summary>
            Get a list of closed orders
            </summary>
            <param name="symbol">[Optional] The symbol to get closed orders for, required for some exchanges, ignored otherwise</param>
            <param name="ct">[Optional] Cancellation token for cancelling the request</param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Interfaces.CommonClients.IBaseRestClient.CancelOrderAsync(System.String,System.String,System.Threading.CancellationToken)">
            <summary>
            Cancel an order by id
            </summary>
            <param name="orderId">The id</param>
            <param name="symbol">[Optional] The symbol the order is on, required for some exchanges, ignored otherwise</param>
            <param name="ct">[Optional] Cancellation token for cancelling the request</param>
            <returns></returns>
        </member>
        <member name="T:CryptoExchange.Net.Interfaces.CommonClients.IFuturesClient">
            <summary>
            Common futures endpoints
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.Interfaces.CommonClients.IFuturesClient.PlaceOrderAsync(System.String,CryptoExchange.Net.CommonObjects.CommonOrderSide,CryptoExchange.Net.CommonObjects.CommonOrderType,System.Decimal,System.Nullable{System.Decimal},System.Nullable{System.Int32},System.String,System.String,System.Threading.CancellationToken)">
            <summary>
            Place an order
            </summary>
            <param name="symbol">The symbol the order is for</param>
            <param name="side">The side of the order</param>
            <param name="type">The type of the order</param>
            <param name="quantity">The quantity of the order</param>
            <param name="price">The price of the order, only for limit orders</param>
            <param name="accountId">[Optional] The account id to place the order on, required for some exchanges, ignored otherwise</param>
            <param name="leverage">[Optional] Leverage for this order. This is needed for some exchanges. For exchanges where this is not needed this parameter is ignored (and should be set before hand)</param>
            <param name="clientOrderId">[Optional] Client specified id for this order</param>
            <param name="ct">[Optional] Cancellation token for cancelling the request</param>
            <returns>The id of the resulting order</returns>
        </member>
        <member name="M:CryptoExchange.Net.Interfaces.CommonClients.IFuturesClient.GetPositionsAsync(System.Threading.CancellationToken)">
            <summary>
            Get position
            </summary>
            <param name="ct">[Optional] Cancellation token for cancelling the request</param>
            <returns></returns>
        </member>
        <member name="T:CryptoExchange.Net.Interfaces.CommonClients.ISpotClient">
            <summary>
            Common spot endpoints
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.Interfaces.CommonClients.ISpotClient.PlaceOrderAsync(System.String,CryptoExchange.Net.CommonObjects.CommonOrderSide,CryptoExchange.Net.CommonObjects.CommonOrderType,System.Decimal,System.Nullable{System.Decimal},System.String,System.String,System.Threading.CancellationToken)">
            <summary>
            Place an order
            </summary>
            <param name="symbol">The symbol the order is for</param>
            <param name="side">The side of the order</param>
            <param name="type">The type of the order</param>
            <param name="quantity">The quantity of the order</param>
            <param name="price">The price of the order, only for limit orders</param>
            <param name="accountId">[Optional] The account id to place the order on, required for some exchanges, ignored otherwise</param>
            <param name="clientOrderId">[Optional] Client specified id for this order</param>
            <param name="ct">[Optional] Cancellation token for cancelling the request</param>
            <returns>The id of the resulting order</returns>
        </member>
        <member name="T:CryptoExchange.Net.Interfaces.IAuthTimeProvider">
            <summary>
            Time provider
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.Interfaces.IAuthTimeProvider.GetTime">
            <summary>
            Get current time
            </summary>
            <returns></returns>
        </member>
        <member name="T:CryptoExchange.Net.Interfaces.IBaseApiClient">
            <summary>
            Base api client
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Interfaces.IBaseApiClient.BaseAddress">
            <summary>
            Base address
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.Interfaces.IBaseApiClient.FormatSymbol(System.String,System.String)">
            <summary>
            Format a base and quote asset to an exchange accepted symbol 
            </summary>
            <param name="baseAsset">The base asset</param>
            <param name="quoteAsset">The quote asset</param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Interfaces.IBaseApiClient.SetApiCredentials``1(``0)">
            <summary>
            Set the API credentials for this API client
            </summary>
            <typeparam name="T"></typeparam>
            <param name="credentials"></param>
        </member>
        <member name="T:CryptoExchange.Net.Interfaces.ICryptoRestClient">
            <summary>
            Client for accessing REST API's for different exchanges
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.Interfaces.ICryptoRestClient.GetSpotClients">
            <summary>
            Get a list of all registered common ISpotClient types
            </summary>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Interfaces.ICryptoRestClient.SpotClient(System.String)">
            <summary>
            Get an ISpotClient implementation by exchange name
            </summary>
            <param name="exchangeName"></param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Interfaces.ICryptoRestClient.TryGet``1(System.Func{``0})">
            <summary>
            Try get 
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="T:CryptoExchange.Net.Interfaces.ICryptoSocketClient">
            <summary>
            Client for accessing Websocket API's for different exchanges
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.Interfaces.ICryptoSocketClient.TryGet``1(System.Func{``0})">
            <summary>
            Try get a client by type for the service collection
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="T:CryptoExchange.Net.Interfaces.IMessageAccessor">
            <summary>
            Message accessor
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Interfaces.IMessageAccessor.IsJson">
            <summary>
            Is this a json message
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Interfaces.IMessageAccessor.OriginalDataAvailable">
            <summary>
            Is the original data available for retrieval
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Interfaces.IMessageAccessor.Underlying">
            <summary>
            The underlying data object
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.Interfaces.IMessageAccessor.Clear">
            <summary>
            Clear internal data structure
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.Interfaces.IMessageAccessor.GetNodeType">
            <summary>
            Get the type of node
            </summary>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Interfaces.IMessageAccessor.GetNodeType(CryptoExchange.Net.Converters.MessageParsing.MessagePath)">
            <summary>
            Get the type of node
            </summary>
            <param name="path">Access path</param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Interfaces.IMessageAccessor.GetValue``1(CryptoExchange.Net.Converters.MessageParsing.MessagePath)">
            <summary>
            Get the value of a path
            </summary>
            <typeparam name="T"></typeparam>
            <param name="path"></param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Interfaces.IMessageAccessor.GetValues``1(CryptoExchange.Net.Converters.MessageParsing.MessagePath)">
            <summary>
            Get the values of an array
            </summary>
            <typeparam name="T"></typeparam>
            <param name="path"></param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Interfaces.IMessageAccessor.Deserialize(System.Type,System.Nullable{CryptoExchange.Net.Converters.MessageParsing.MessagePath})">
            <summary>
            Deserialize the message into this type
            </summary>
            <param name="type"></param>
            <param name="path"></param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Interfaces.IMessageAccessor.Deserialize``1(System.Nullable{CryptoExchange.Net.Converters.MessageParsing.MessagePath})">
            <summary>
            Deserialize the message into this type
            </summary>
            <param name="path"></param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Interfaces.IMessageAccessor.GetOriginalString">
            <summary>
            Get the original string value
            </summary>
            <returns></returns>
        </member>
        <member name="T:CryptoExchange.Net.Interfaces.IStreamMessageAccessor">
            <summary>
            Stream message accessor
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.Interfaces.IStreamMessageAccessor.Read(System.IO.Stream,System.Boolean)">
            <summary>
            Load a stream message
            </summary>
            <param name="stream"></param>
            <param name="bufferStream"></param>
        </member>
        <member name="T:CryptoExchange.Net.Interfaces.IByteMessageAccessor">
            <summary>
            Byte message accessor
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.Interfaces.IByteMessageAccessor.Read(System.ReadOnlyMemory{System.Byte})">
            <summary>
            Load a data message
            </summary>
            <param name="data"></param>
        </member>
        <member name="T:CryptoExchange.Net.Interfaces.IMessageProcessor">
            <summary>
            Message processor
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Interfaces.IMessageProcessor.Id">
            <summary>
            Id of the processor
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Interfaces.IMessageProcessor.CanHandleData">
            <summary>
            Whether this listener can handle data
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Interfaces.IMessageProcessor.ListenerIdentifiers">
            <summary>
            The identifiers for this processor
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.Interfaces.IMessageProcessor.Handle(CryptoExchange.Net.Sockets.SocketConnection,CryptoExchange.Net.Objects.Sockets.DataEvent{System.Object})">
            <summary>
            Handle a message
            </summary>
            <param name="connection"></param>
            <param name="message"></param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Interfaces.IMessageProcessor.GetMessageType(CryptoExchange.Net.Interfaces.IMessageAccessor)">
            <summary>
            Get the type the message should be deserialized to
            </summary>
            <param name="messageAccessor"></param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Interfaces.IMessageProcessor.Deserialize(CryptoExchange.Net.Interfaces.IMessageAccessor,System.Type)">
            <summary>
            Deserialize a message into object of type
            </summary>
            <param name="accessor"></param>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="T:CryptoExchange.Net.Interfaces.IMessageSerializer">
            <summary>
            Serializer interface
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.Interfaces.IMessageSerializer.Serialize(System.Object)">
            <summary>
            Serialize an object to a string
            </summary>
            <param name="message"></param>
            <returns></returns>
        </member>
        <member name="T:CryptoExchange.Net.Interfaces.INonceProvider">
            <summary>
            A provider for a nonce value used when signing requests
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.Interfaces.INonceProvider.GetNonce">
            <summary>
            Get nonce value. Nonce value should be unique and incremental for each call
            </summary>
            <returns>Nonce value</returns>
        </member>
        <member name="T:CryptoExchange.Net.Interfaces.IOrderBookFactory`1">
            <summary>
            Factory for ISymbolOrderBook instances
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.Interfaces.IOrderBookFactory`1.Create(System.String,System.Action{`0})">
            <summary>
            Create a new order book by symbol name
            </summary>
            <param name="symbol">Symbol name</param>
            <param name="options">Options for the order book</param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Interfaces.IOrderBookFactory`1.Create(System.String,System.String,System.Action{`0})">
            <summary>
            Create a new order book by base and quote asset names
            </summary>
            <param name="baseAsset">Base asset name</param>
            <param name="quoteAsset">Quote asset name</param>
            <param name="options">Options for the order book</param>
            <returns></returns>
        </member>
        <member name="T:CryptoExchange.Net.Interfaces.IRateLimiter">
            <summary>
            Rate limiter interface
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.Interfaces.IRateLimiter.LimitRequestAsync(Microsoft.Extensions.Logging.ILogger,System.String,System.Net.Http.HttpMethod,System.Boolean,System.Security.SecureString,CryptoExchange.Net.Objects.RateLimitingBehaviour,System.Int32,System.Threading.CancellationToken)">
            <summary>
            Limit a request based on previous requests made
            </summary>
            <param name="log">The logger</param>
            <param name="endpoint">The endpoint the request is for</param>
            <param name="method">The Http request method</param>
            <param name="signed">Whether the request is singed(private) or not</param>
            <param name="apiKey">The api key making this request</param>
            <param name="limitBehaviour">The limit behavior for when the limit is reached</param>
            <param name="requestWeight">The weight of the request</param>
            <param name="ct">Cancellation token to cancel waiting</param>
            <returns>The time in milliseconds spend waiting</returns>
        </member>
        <member name="T:CryptoExchange.Net.Interfaces.IRequest">
            <summary>
            Request interface
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Interfaces.IRequest.Accept">
            <summary>
            Accept header
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Interfaces.IRequest.Content">
            <summary>
            Content
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Interfaces.IRequest.Method">
            <summary>
            Method
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Interfaces.IRequest.Uri">
            <summary>
            Uri
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Interfaces.IRequest.RequestId">
            <summary>
            internal request id for tracing
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.Interfaces.IRequest.SetContent(System.Byte[])">
            <summary>
            Set byte content
            </summary>
            <param name="data"></param>
        </member>
        <member name="M:CryptoExchange.Net.Interfaces.IRequest.SetContent(System.String,System.String)">
            <summary>
            Set string content
            </summary>
            <param name="data"></param>
            <param name="contentType"></param>
        </member>
        <member name="M:CryptoExchange.Net.Interfaces.IRequest.AddHeader(System.String,System.String)">
            <summary>
            Add a header to the request
            </summary>
            <param name="key"></param>
            <param name="value"></param>
        </member>
        <member name="M:CryptoExchange.Net.Interfaces.IRequest.GetHeaders">
            <summary>
            Get all headers
            </summary>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Interfaces.IRequest.GetResponseAsync(System.Threading.CancellationToken)">
            <summary>
            Get the response
            </summary>
            <param name="cancellationToken"></param>
            <returns></returns>
        </member>
        <member name="T:CryptoExchange.Net.Interfaces.IRequestFactory">
            <summary>
            Request factory interface
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.Interfaces.IRequestFactory.Create(System.Net.Http.HttpMethod,System.Uri,System.Int32)">
            <summary>
            Create a request for an uri
            </summary>
            <param name="method"></param>
            <param name="uri"></param>
            <param name="requestId"></param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Interfaces.IRequestFactory.Configure(CryptoExchange.Net.Objects.ApiProxy,System.TimeSpan,System.Net.Http.HttpClient)">
            <summary>
            Configure the requests created by this factory
            </summary>
            <param name="requestTimeout">Request timeout to use</param>
            <param name="httpClient">Optional shared http client instance</param>
            <param name="proxy">Optional proxy to use when no http client is provided</param>
        </member>
        <member name="T:CryptoExchange.Net.Interfaces.IResponse">
            <summary>
            Response object interface
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Interfaces.IResponse.StatusCode">
            <summary>
            The response status code
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Interfaces.IResponse.IsSuccessStatusCode">
            <summary>
            Whether the status code indicates a success status
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Interfaces.IResponse.ContentLength">
            <summary>
            The length of the response in bytes
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Interfaces.IResponse.ResponseHeaders">
            <summary>
            The response headers
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.Interfaces.IResponse.GetResponseStreamAsync">
            <summary>
            Get the response stream
            </summary>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Interfaces.IResponse.Close">
            <summary>
            Close the response
            </summary>
        </member>
        <member name="T:CryptoExchange.Net.Interfaces.IRestApiClient">
            <summary>
            Base rest API client
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Interfaces.IRestApiClient.RequestFactory">
            <summary>
            The factory for creating requests. Used for unit testing
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Interfaces.IRestApiClient.TotalRequestsMade">
            <summary>
            Total amount of requests made with this API client
            </summary>
        </member>
        <member name="T:CryptoExchange.Net.Interfaces.IRestClient">
            <summary>
            Base class for rest API implementations
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Interfaces.IRestClient.ClientOptions">
            <summary>
            The options provided for this client
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Interfaces.IRestClient.TotalRequestsMade">
            <summary>
            The total amount of requests made with this client
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Interfaces.IRestClient.Exchange">
            <summary>
            The exchange name
            </summary>
        </member>
        <member name="T:CryptoExchange.Net.Interfaces.ISocketApiClient">
            <summary>
            Socket API client
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Interfaces.ISocketApiClient.CurrentConnections">
            <summary>
            The current amount of socket connections on the API client
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Interfaces.ISocketApiClient.CurrentSubscriptions">
            <summary>
            The current amount of subscriptions over all connections
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Interfaces.ISocketApiClient.IncomingKbps">
            <summary>
            Incoming data kpbs
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Interfaces.ISocketApiClient.SocketFactory">
            <summary>
            The factory for creating sockets. Used for unit testing
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Interfaces.ISocketApiClient.ClientOptions">
            <summary>
            Current client options
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Interfaces.ISocketApiClient.ApiOptions">
            <summary>
            Current API options
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.Interfaces.ISocketApiClient.GetSubscriptionsState(System.Boolean)">
            <summary>
            Log the current state of connections and subscriptions
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.Interfaces.ISocketApiClient.ReconnectAsync">
            <summary>
            Reconnect all connections
            </summary>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Interfaces.ISocketApiClient.UnsubscribeAllAsync">
            <summary>
            Unsubscribe all subscriptions
            </summary>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Interfaces.ISocketApiClient.UnsubscribeAsync(System.Int32)">
            <summary>
            Unsubscribe an update subscription
            </summary>
            <param name="subscriptionId">The id of the subscription to unsubscribe</param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Interfaces.ISocketApiClient.UnsubscribeAsync(CryptoExchange.Net.Objects.Sockets.UpdateSubscription)">
            <summary>
            Unsubscribe an update subscription
            </summary>
            <param name="subscription">The subscription to unsubscribe</param>
            <returns></returns>
        </member>
        <member name="T:CryptoExchange.Net.Interfaces.ISocketClient">
            <summary>
            Base class for socket API implementations
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Interfaces.ISocketClient.Exchange">
            <summary>
            The exchange name
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Interfaces.ISocketClient.ClientOptions">
            <summary>
            The options provided for this client
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Interfaces.ISocketClient.IncomingKbps">
            <summary>
            Incoming kilobytes per second of data
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Interfaces.ISocketClient.CurrentConnections">
            <summary>
            The current amount of connections to the API from this client. A connection can have multiple subscriptions.
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Interfaces.ISocketClient.CurrentSubscriptions">
            <summary>
            The current amount of subscriptions running from the client
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.Interfaces.ISocketClient.UnsubscribeAsync(System.Int32)">
            <summary>
            Unsubscribe from a stream using the subscription id received when starting the subscription
            </summary>
            <param name="subscriptionId">The id of the subscription to unsubscribe</param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Interfaces.ISocketClient.UnsubscribeAsync(CryptoExchange.Net.Objects.Sockets.UpdateSubscription)">
            <summary>
            Unsubscribe from a stream
            </summary>
            <param name="subscription">The subscription to unsubscribe</param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Interfaces.ISocketClient.UnsubscribeAllAsync">
            <summary>
            Unsubscribe all subscriptions
            </summary>
            <returns></returns>
        </member>
        <member name="T:CryptoExchange.Net.Interfaces.ISymbolOrderBook">
            <summary>
            Interface for order book
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Interfaces.ISymbolOrderBook.Exchange">
            <summary>
            The exchange the book is for
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Interfaces.ISymbolOrderBook.Api">
            <summary>
            The Api the book is for
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Interfaces.ISymbolOrderBook.Status">
            <summary>
            The status of the order book. Order book is up to date when the status is `Synced`
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Interfaces.ISymbolOrderBook.LastSequenceNumber">
            <summary>
            Last update identifier
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Interfaces.ISymbolOrderBook.Symbol">
            <summary>
            The symbol of the order book
            </summary>
        </member>
        <member name="E:CryptoExchange.Net.Interfaces.ISymbolOrderBook.OnStatusChange">
            <summary>
            Event when the state changes
            </summary>
        </member>
        <member name="E:CryptoExchange.Net.Interfaces.ISymbolOrderBook.OnOrderBookUpdate">
            <summary>
            Event when order book was updated. Be careful! It can generate a lot of events at high-liquidity markets
            </summary>    
        </member>
        <member name="E:CryptoExchange.Net.Interfaces.ISymbolOrderBook.OnBestOffersChanged">
            <summary>
            Event when the BestBid or BestAsk changes ie a Pricing Tick
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Interfaces.ISymbolOrderBook.UpdateTime">
            <summary>
            Timestamp of the last update
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Interfaces.ISymbolOrderBook.AskCount">
            <summary>
            The number of asks in the book
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Interfaces.ISymbolOrderBook.BidCount">
            <summary>
            The number of bids in the book
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Interfaces.ISymbolOrderBook.Book">
            <summary>
            Get a snapshot of the book at this moment
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Interfaces.ISymbolOrderBook.Asks">
            <summary>
            The list of asks
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Interfaces.ISymbolOrderBook.Bids">
            <summary>
            The list of bids
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Interfaces.ISymbolOrderBook.BestBid">
            <summary>
            The best bid currently in the order book
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Interfaces.ISymbolOrderBook.BestAsk">
            <summary>
            The best ask currently in the order book
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Interfaces.ISymbolOrderBook.BestOffers">
            <summary>
            BestBid/BesAsk returned as a pair
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.Interfaces.ISymbolOrderBook.StartAsync(System.Nullable{System.Threading.CancellationToken})">
            <summary>
            Start connecting and synchronizing the order book
            </summary>
            <param name="ct">A cancellation token to stop the order book when canceled</param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Interfaces.ISymbolOrderBook.StopAsync">
            <summary>
            Stop syncing the order book
            </summary>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Interfaces.ISymbolOrderBook.CalculateAverageFillPrice(System.Decimal,CryptoExchange.Net.Objects.OrderBookEntryType)">
            <summary>
            Get the average price that a market order would fill at at the current order book state. This is no guarentee that an order of that quantity would actually be filled
            at that price since between this calculation and the order placement the book might have changed.
            </summary>
            <param name="quantity">The quantity in base asset to fill</param>
            <param name="type">The type</param>
            <returns>Average fill price</returns>
        </member>
        <member name="M:CryptoExchange.Net.Interfaces.ISymbolOrderBook.CalculateTradableAmount(System.Decimal,CryptoExchange.Net.Objects.OrderBookEntryType)">
            <summary>
            Get the amount of base asset which can be traded with the quote quantity when placing a market order at at the current order book state. 
            This is no guarentee that an order of that quantity would actually be fill the quantity returned by this since between this calculation and the order placement the book might have changed.
            </summary>
            <param name="quoteQuantity">The quantity in quote asset looking to trade</param>
            <param name="type">The type</param>
            <returns>Amount of base asset tradable with the specified amount of quote asset</returns>
        </member>
        <member name="M:CryptoExchange.Net.Interfaces.ISymbolOrderBook.ToString(System.Int32)">
            <summary>
            String representation of the top x entries
            </summary>
            <returns></returns>
        </member>
        <member name="T:CryptoExchange.Net.Interfaces.ISymbolOrderBookEntry">
            <summary>
            Interface for order book entries
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Interfaces.ISymbolOrderBookEntry.Quantity">
            <summary>
            The quantity of the entry
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Interfaces.ISymbolOrderBookEntry.Price">
            <summary>
            The price of the entry
            </summary>
        </member>
        <member name="T:CryptoExchange.Net.Interfaces.ISymbolOrderSequencedBookEntry">
            <summary>
            Interface for order book entries
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Interfaces.ISymbolOrderSequencedBookEntry.Sequence">
            <summary>
            Sequence of the update
            </summary>
        </member>
        <member name="T:CryptoExchange.Net.Interfaces.IWebsocket">
            <summary>
            Websocket connection interface
            </summary>
        </member>
        <member name="E:CryptoExchange.Net.Interfaces.IWebsocket.OnClose">
            <summary>
            Websocket closed event
            </summary>
        </member>
        <member name="E:CryptoExchange.Net.Interfaces.IWebsocket.OnStreamMessage">
            <summary>
            Websocket message received event
            </summary>
        </member>
        <member name="E:CryptoExchange.Net.Interfaces.IWebsocket.OnRequestSent">
            <summary>
            Websocket sent event, RequestId as parameter
            </summary>
        </member>
        <member name="E:CryptoExchange.Net.Interfaces.IWebsocket.OnRequestRateLimited">
            <summary>
            Websocket query was ratelimited and couldn't be send
            </summary>
        </member>
        <member name="E:CryptoExchange.Net.Interfaces.IWebsocket.OnError">
            <summary>
            Websocket error event
            </summary>
        </member>
        <member name="E:CryptoExchange.Net.Interfaces.IWebsocket.OnOpen">
            <summary>
            Websocket opened event
            </summary>
        </member>
        <member name="E:CryptoExchange.Net.Interfaces.IWebsocket.OnReconnecting">
            <summary>
            Websocket has lost connection to the server and is attempting to reconnect
            </summary>
        </member>
        <member name="E:CryptoExchange.Net.Interfaces.IWebsocket.OnReconnected">
            <summary>
            Websocket has reconnected to the server
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Interfaces.IWebsocket.GetReconnectionUrl">
            <summary>
            Get reconntion url
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Interfaces.IWebsocket.Id">
            <summary>
            Unique id for this socket
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Interfaces.IWebsocket.IncomingKbps">
            <summary>
            The current kilobytes per second of data being received, averaged over the last 3 seconds
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Interfaces.IWebsocket.Uri">
            <summary>
            The uri the socket connects to
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Interfaces.IWebsocket.IsClosed">
            <summary>
            Whether the socket connection is closed
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Interfaces.IWebsocket.IsOpen">
            <summary>
            Whether the socket connection is open
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.Interfaces.IWebsocket.ConnectAsync">
            <summary>
            Connect the socket
            </summary>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Interfaces.IWebsocket.Send(System.Int32,System.String,System.Int32)">
            <summary>
            Send data
            </summary>
            <param name="id"></param>
            <param name="data"></param>
            <param name="weight"></param>
        </member>
        <member name="M:CryptoExchange.Net.Interfaces.IWebsocket.ReconnectAsync">
            <summary>
            Reconnect the socket
            </summary>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Interfaces.IWebsocket.CloseAsync">
            <summary>
            Close the connection
            </summary>
            <returns></returns>
        </member>
        <member name="T:CryptoExchange.Net.Interfaces.IWebsocketFactory">
            <summary>
            Websocket factory interface
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.Interfaces.IWebsocketFactory.CreateWebsocket(Microsoft.Extensions.Logging.ILogger,CryptoExchange.Net.Objects.Sockets.WebSocketParameters)">
            <summary>
            Create a websocket for an url
            </summary>
            <param name="logger">The logger</param>
            <param name="parameters">The parameters to use for the connection</param>
            <returns></returns>
        </member>
        <member name="T:CryptoExchange.Net.Objects.ApiProxy">
            <summary>
            Proxy info
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Objects.ApiProxy.Host">
            <summary>
            The host address of the proxy
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Objects.ApiProxy.Port">
            <summary>
            The port of the proxy
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Objects.ApiProxy.Login">
            <summary>
            The login of the proxy
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Objects.ApiProxy.Password">
            <summary>
            The password of the proxy
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.Objects.ApiProxy.#ctor(System.String,System.Int32)">
            <summary>
            Create new settings for a proxy
            </summary>
            <param name="host">The proxy hostname/ip</param>
            <param name="port">The proxy port</param>
        </member>
        <member name="M:CryptoExchange.Net.Objects.ApiProxy.#ctor(System.String,System.Int32,System.String,System.String)">
            <summary>
            Create new settings for a proxy
            </summary>
            <param name="host">The proxy hostname/ip</param>
            <param name="port">The proxy port</param>
            <param name="login">The proxy login</param>
            <param name="password">The proxy password</param>
        </member>
        <member name="M:CryptoExchange.Net.Objects.ApiProxy.#ctor(System.String,System.Int32,System.String,System.Security.SecureString)">
            <summary>
            Create new settings for a proxy
            </summary>
            <param name="host">The proxy hostname/ip</param>
            <param name="port">The proxy port</param>
            <param name="login">The proxy login</param>
            <param name="password">The proxy password</param>
        </member>
        <member name="T:CryptoExchange.Net.Objects.AsyncResetEvent">
            <summary>
            Async auto reset based on Stephen Toub`s implementation
            https://devblogs.microsoft.com/pfxteam/building-async-coordination-primitives-part-2-asyncautoresetevent/
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.Objects.AsyncResetEvent.#ctor(System.Boolean,System.Boolean)">
            <summary>
            New AsyncResetEvent
            </summary>
            <param name="initialState"></param>
            <param name="reset"></param>
        </member>
        <member name="M:CryptoExchange.Net.Objects.AsyncResetEvent.WaitAsync(System.Nullable{System.TimeSpan})">
            <summary>
            Wait for the AutoResetEvent to be set
            </summary>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Objects.AsyncResetEvent.Set">
            <summary>
            Signal a waiter
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.Objects.AsyncResetEvent.Dispose">
            <summary>
            Dispose
            </summary>
        </member>
        <member name="T:CryptoExchange.Net.Objects.ByteOrderComparer">
            <summary>
            Comparer for byte order
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.Objects.ByteOrderComparer.Compare(System.Byte[],System.Byte[])">
            <summary>
            Compare function
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <returns></returns>
        </member>
        <member name="T:CryptoExchange.Net.Objects.CallResult">
            <summary>
            The result of an operation
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Objects.CallResult.Error">
            <summary>
            An error if the call didn't succeed, will always be filled if Success = false
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Objects.CallResult.Success">
            <summary>
            Whether the call was successful
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.Objects.CallResult.#ctor(CryptoExchange.Net.Objects.Error)">
            <summary>
            ctor
            </summary>
            <param name="error"></param>
        </member>
        <member name="M:CryptoExchange.Net.Objects.CallResult.op_Implicit(CryptoExchange.Net.Objects.CallResult)~System.Boolean">
            <summary>
            Overwrite bool check so we can use if(callResult) instead of if(callResult.Success)
            </summary>
            <param name="obj"></param>
        </member>
        <member name="M:CryptoExchange.Net.Objects.CallResult.ToString">
            <inheritdoc />
        </member>
        <member name="T:CryptoExchange.Net.Objects.CallResult`1">
            <summary>
            The result of an operation
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:CryptoExchange.Net.Objects.CallResult`1.Data">
            <summary>
            The data returned by the call, only available when Success = true
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Objects.CallResult`1.OriginalData">
            <summary>
            The original data returned by the call, only available when `OutputOriginalData` is set to `true` in the client options
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.Objects.CallResult`1.#ctor(`0,System.String,CryptoExchange.Net.Objects.Error)">
            <summary>
            ctor
            </summary>
            <param name="data"></param>
            <param name="originalData"></param>
            <param name="error"></param>
        </member>
        <member name="M:CryptoExchange.Net.Objects.CallResult`1.#ctor(`0)">
            <summary>
            Create a new data result
            </summary>
            <param name="data">The data to return</param>
        </member>
        <member name="M:CryptoExchange.Net.Objects.CallResult`1.#ctor(CryptoExchange.Net.Objects.Error)">
            <summary>
            Create a new error result
            </summary>
            <param name="error">The erro rto return</param>
        </member>
        <member name="M:CryptoExchange.Net.Objects.CallResult`1.#ctor(CryptoExchange.Net.Objects.Error,System.String)">
            <summary>
            Create a new error result
            </summary>
            <param name="error">The error to return</param>
            <param name="originalData">The original response data</param>
        </member>
        <member name="M:CryptoExchange.Net.Objects.CallResult`1.op_Implicit(CryptoExchange.Net.Objects.CallResult{`0})~System.Boolean">
            <summary>
            Overwrite bool check so we can use if(callResult) instead of if(callResult.Success)
            </summary>
            <param name="obj"></param>
        </member>
        <member name="M:CryptoExchange.Net.Objects.CallResult`1.GetResultOrError(`0@,CryptoExchange.Net.Objects.Error@)">
            <summary>
            Whether the call was successful or not. Useful for nullability checking.
            </summary>
            <param name="data">The data returned by the call.</param>
            <param name="error"><see cref="T:CryptoExchange.Net.Objects.Error"/> on failure.</param>
            <returns><c>true</c> when <see cref="T:CryptoExchange.Net.Objects.CallResult`1"/> succeeded, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:CryptoExchange.Net.Objects.CallResult`1.As``1(``0)">
            <summary>
            Copy the WebCallResult to a new data type
            </summary>
            <typeparam name="K">The new type</typeparam>
            <param name="data">The data of the new type</param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Objects.CallResult`1.AsDataless">
            <summary>
            Copy as a dataless result
            </summary>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Objects.CallResult`1.AsDatalessError(CryptoExchange.Net.Objects.Error)">
            <summary>
            Copy as a dataless result
            </summary>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Objects.CallResult`1.AsError``1(CryptoExchange.Net.Objects.Error)">
            <summary>
            Copy the WebCallResult to a new data type
            </summary>
            <typeparam name="K">The new type</typeparam>
            <param name="error">The error to return</param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Objects.CallResult`1.ToString">
            <inheritdoc />
        </member>
        <member name="T:CryptoExchange.Net.Objects.WebCallResult">
            <summary>
            The result of a request
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Objects.WebCallResult.RequestMethod">
            <summary>
            The request http method
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Objects.WebCallResult.RequestHeaders">
            <summary>
            The headers sent with the request
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Objects.WebCallResult.RequestId">
            <summary>
            The request id
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Objects.WebCallResult.RequestUrl">
            <summary>
            The url which was requested
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Objects.WebCallResult.RequestBody">
            <summary>
            The body of the request
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Objects.WebCallResult.ResponseStatusCode">
            <summary>
            The status code of the response. Note that a OK status does not always indicate success, check the Success parameter for this.
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Objects.WebCallResult.ResponseHeaders">
            <summary>
            The response headers
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Objects.WebCallResult.ResponseTime">
            <summary>
            The time between sending the request and receiving the response
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.Objects.WebCallResult.#ctor(System.Nullable{System.Net.HttpStatusCode},System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.Collections.Generic.IEnumerable{System.String}}},System.Nullable{System.TimeSpan},System.Nullable{System.Int32},System.String,System.String,System.Net.Http.HttpMethod,System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.Collections.Generic.IEnumerable{System.String}}},CryptoExchange.Net.Objects.Error)">
            <summary>
            ctor
            </summary>
            <param name="code"></param>
            <param name="responseHeaders"></param>
            <param name="responseTime"></param>
            <param name="requestId"></param>
            <param name="requestUrl"></param>
            <param name="requestBody"></param>
            <param name="requestMethod"></param>
            <param name="requestHeaders"></param>
            <param name="error"></param>
        </member>
        <member name="M:CryptoExchange.Net.Objects.WebCallResult.#ctor(CryptoExchange.Net.Objects.Error)">
            <summary>
            ctor
            </summary>
            <param name="error"></param>
        </member>
        <member name="M:CryptoExchange.Net.Objects.WebCallResult.AsError(CryptoExchange.Net.Objects.Error)">
            <summary>
            Return the result as an error result
            </summary>
            <param name="error">The error returned</param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Objects.WebCallResult.ToString">
            <inheritdoc />
        </member>
        <member name="T:CryptoExchange.Net.Objects.WebCallResult`1">
            <summary>
            The result of a request
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:CryptoExchange.Net.Objects.WebCallResult`1.RequestMethod">
            <summary>
            The request http method
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Objects.WebCallResult`1.RequestHeaders">
            <summary>
            The headers sent with the request
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Objects.WebCallResult`1.RequestId">
            <summary>
            The request id
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Objects.WebCallResult`1.RequestUrl">
            <summary>
            The url which was requested
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Objects.WebCallResult`1.RequestBody">
            <summary>
            The body of the request
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Objects.WebCallResult`1.ResponseStatusCode">
            <summary>
            The status code of the response. Note that a OK status does not always indicate success, check the Success parameter for this.
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Objects.WebCallResult`1.ResponseLength">
            <summary>
            Length in bytes of the response
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Objects.WebCallResult`1.ResponseHeaders">
            <summary>
            The response headers
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Objects.WebCallResult`1.ResponseTime">
            <summary>
            The time between sending the request and receiving the response
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.Objects.WebCallResult`1.#ctor(System.Nullable{System.Net.HttpStatusCode},System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.Collections.Generic.IEnumerable{System.String}}},System.Nullable{System.TimeSpan},System.Nullable{System.Int64},System.String,System.Nullable{System.Int32},System.String,System.String,System.Net.Http.HttpMethod,System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.Collections.Generic.IEnumerable{System.String}}},`0,CryptoExchange.Net.Objects.Error)">
            <summary>
            Create a new result
            </summary>
            <param name="code"></param>
            <param name="responseHeaders"></param>
            <param name="responseTime"></param>
            <param name="responseLength"></param>
            <param name="originalData"></param>
            <param name="requestId"></param>
            <param name="requestUrl"></param>
            <param name="requestBody"></param>
            <param name="requestMethod"></param>
            <param name="requestHeaders"></param>
            <param name="data"></param>
            <param name="error"></param>
        </member>
        <member name="M:CryptoExchange.Net.Objects.WebCallResult`1.AsDataless">
            <summary>
            Copy as a dataless result
            </summary>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Objects.WebCallResult`1.AsDatalessError(CryptoExchange.Net.Objects.Error)">
            <summary>
            Copy as a dataless result
            </summary>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Objects.WebCallResult`1.#ctor(CryptoExchange.Net.Objects.Error)">
            <summary>
            Create a new error result
            </summary>
            <param name="error">The error</param>
        </member>
        <member name="M:CryptoExchange.Net.Objects.WebCallResult`1.As``1(``0)">
            <summary>
            Copy the WebCallResult to a new data type
            </summary>
            <typeparam name="K">The new type</typeparam>
            <param name="data">The data of the new type</param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Objects.WebCallResult`1.AsError``1(CryptoExchange.Net.Objects.Error)">
            <summary>
            Copy the WebCallResult to a new data type
            </summary>
            <typeparam name="K">The new type</typeparam>
            <param name="error">The error returned</param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Objects.WebCallResult`1.ToString">
            <inheritdoc />
        </member>
        <member name="T:CryptoExchange.Net.Objects.Constants">
            <summary>
            Constants
            </summary>
        </member>
        <member name="F:CryptoExchange.Net.Objects.Constants.JsonContentHeader">
            <summary>
            Json content type header
            </summary>
        </member>
        <member name="F:CryptoExchange.Net.Objects.Constants.FormContentHeader">
            <summary>
            Form content type header
            </summary>
        </member>
        <member name="T:CryptoExchange.Net.Objects.RateLimitingBehaviour">
            <summary>
            What to do when a request would exceed the rate limit
            </summary>
        </member>
        <member name="F:CryptoExchange.Net.Objects.RateLimitingBehaviour.Fail">
            <summary>
            Fail the request
            </summary>
        </member>
        <member name="F:CryptoExchange.Net.Objects.RateLimitingBehaviour.Wait">
            <summary>
            Wait till the request can be send
            </summary>
        </member>
        <member name="T:CryptoExchange.Net.Objects.RateLimitWindowType">
            <summary>
            What to do when a request would exceed the rate limit
            </summary>
        </member>
        <member name="F:CryptoExchange.Net.Objects.RateLimitWindowType.Sliding">
            <summary>
            A sliding window
            </summary>
        </member>
        <member name="F:CryptoExchange.Net.Objects.RateLimitWindowType.Fixed">
            <summary>
            A fixed interval window
            </summary>
        </member>
        <member name="F:CryptoExchange.Net.Objects.RateLimitWindowType.FixedAfterFirst">
            <summary>
            A fixed interval starting after the first request
            </summary>
        </member>
        <member name="F:CryptoExchange.Net.Objects.RateLimitWindowType.Decay">
            <summary>
            Decaying window
            </summary>
        </member>
        <member name="T:CryptoExchange.Net.Objects.HttpMethodParameterPosition">
            <summary>
            Where the parameters for a HttpMethod should be added in a request
            </summary>
        </member>
        <member name="F:CryptoExchange.Net.Objects.HttpMethodParameterPosition.InBody">
            <summary>
            Parameters in body
            </summary>
        </member>
        <member name="F:CryptoExchange.Net.Objects.HttpMethodParameterPosition.InUri">
            <summary>
            Parameters in url
            </summary>
        </member>
        <member name="T:CryptoExchange.Net.Objects.RequestBodyFormat">
            <summary>
            The format of the request body
            </summary>
        </member>
        <member name="F:CryptoExchange.Net.Objects.RequestBodyFormat.FormData">
            <summary>
            Form data
            </summary>
        </member>
        <member name="F:CryptoExchange.Net.Objects.RequestBodyFormat.Json">
            <summary>
            Json
            </summary>
        </member>
        <member name="T:CryptoExchange.Net.Objects.OrderBookStatus">
            <summary>
            Status of the order book
            </summary>
        </member>
        <member name="F:CryptoExchange.Net.Objects.OrderBookStatus.Disconnected">
            <summary>
            Not connected
            </summary>
        </member>
        <member name="F:CryptoExchange.Net.Objects.OrderBookStatus.Connecting">
            <summary>
            Connecting
            </summary>
        </member>
        <member name="F:CryptoExchange.Net.Objects.OrderBookStatus.Reconnecting">
            <summary>
            Reconnecting
            </summary>
        </member>
        <member name="F:CryptoExchange.Net.Objects.OrderBookStatus.Syncing">
            <summary>
            Syncing data
            </summary>
        </member>
        <member name="F:CryptoExchange.Net.Objects.OrderBookStatus.Synced">
            <summary>
            Data synced, order book is up to date
            </summary>
        </member>
        <member name="F:CryptoExchange.Net.Objects.OrderBookStatus.Disposing">
            <summary>
            Disposing
            </summary>
        </member>
        <member name="F:CryptoExchange.Net.Objects.OrderBookStatus.Disposed">
            <summary>
            Disposed
            </summary>
        </member>
        <member name="T:CryptoExchange.Net.Objects.OrderBookEntryType">
            <summary>
            Order book entry type
            </summary>
        </member>
        <member name="F:CryptoExchange.Net.Objects.OrderBookEntryType.Ask">
            <summary>
            Ask
            </summary>
        </member>
        <member name="F:CryptoExchange.Net.Objects.OrderBookEntryType.Bid">
            <summary>
            Bid
            </summary>
        </member>
        <member name="T:CryptoExchange.Net.Objects.ArrayParametersSerialization">
            <summary>
            Define how array parameters should be send
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "F:CryptoExchange.Net.Objects.ArrayParametersSerialization.MultipleValues" -->
        <!-- Badly formed XML comment ignored for member "F:CryptoExchange.Net.Objects.ArrayParametersSerialization.Array" -->
        <member name="F:CryptoExchange.Net.Objects.ArrayParametersSerialization.JsonArray">
            <summary>
            Send as key=[value1, value2]
            </summary>
        </member>
        <member name="T:CryptoExchange.Net.Objects.RoundingType">
            <summary>
            How to round
            </summary>
        </member>
        <member name="F:CryptoExchange.Net.Objects.RoundingType.Down">
            <summary>
            Round down (flooring)
            </summary>
        </member>
        <member name="F:CryptoExchange.Net.Objects.RoundingType.Closest">
            <summary>
            Round to closest value
            </summary>
        </member>
        <member name="T:CryptoExchange.Net.Objects.SocketUpdateType">
            <summary>
            Type of the update
            </summary>
        </member>
        <member name="F:CryptoExchange.Net.Objects.SocketUpdateType.Update">
            <summary>
            A update
            </summary>
        </member>
        <member name="F:CryptoExchange.Net.Objects.SocketUpdateType.Snapshot">
            <summary>
            A snapshot, generally send at the start of the connection
            </summary>
        </member>
        <member name="T:CryptoExchange.Net.Objects.Error">
            <summary>
            Base class for errors
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Objects.Error.Code">
            <summary>
            The error code from the server
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Objects.Error.Message">
            <summary>
            The message for the error that occurred
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Objects.Error.Data">
            <summary>
            The data which caused the error
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.Objects.Error.#ctor(System.Nullable{System.Int32},System.String,System.Object)">
            <summary>
            ctor
            </summary>
            <param name="code"></param>
            <param name="message"></param>
            <param name="data"></param>
        </member>
        <member name="M:CryptoExchange.Net.Objects.Error.ToString">
            <summary>
            String representation
            </summary>
            <returns></returns>
        </member>
        <member name="T:CryptoExchange.Net.Objects.CantConnectError">
            <summary>
            Cant reach server error
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.Objects.CantConnectError.#ctor">
            <summary>
            ctor
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.Objects.CantConnectError.#ctor(System.Nullable{System.Int32},System.String,System.Object)">
            <summary>
            ctor
            </summary>
            <param name="code"></param>
            <param name="message"></param>
            <param name="data"></param>
        </member>
        <member name="T:CryptoExchange.Net.Objects.NoApiCredentialsError">
            <summary>
            No api credentials provided while trying to access a private endpoint
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.Objects.NoApiCredentialsError.#ctor">
            <summary>
            ctor
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.Objects.NoApiCredentialsError.#ctor(System.Nullable{System.Int32},System.String,System.Object)">
            <summary>
            ctor
            </summary>
            <param name="code"></param>
            <param name="message"></param>
            <param name="data"></param>
        </member>
        <member name="T:CryptoExchange.Net.Objects.ServerError">
            <summary>
            Error returned by the server
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.Objects.ServerError.#ctor(System.String,System.Object)">
            <summary>
            ctor
            </summary>
            <param name="message"></param>
            <param name="data"></param>
        </member>
        <member name="M:CryptoExchange.Net.Objects.ServerError.#ctor(System.Int32,System.String,System.Object)">
            <summary>
            ctor
            </summary>
            <param name="code"></param>
            <param name="message"></param>
            <param name="data"></param>
        </member>
        <member name="M:CryptoExchange.Net.Objects.ServerError.#ctor(System.Nullable{System.Int32},System.String,System.Object)">
            <summary>
            ctor
            </summary>
            <param name="code"></param>
            <param name="message"></param>
            <param name="data"></param>
        </member>
        <member name="T:CryptoExchange.Net.Objects.WebError">
            <summary>
            Web error returned by the server
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.Objects.WebError.#ctor(System.String,System.Object)">
            <summary>
            ctor
            </summary>
            <param name="message"></param>
            <param name="data"></param>
        </member>
        <member name="M:CryptoExchange.Net.Objects.WebError.#ctor(System.Int32,System.String,System.Object)">
            <summary>
            ctor
            </summary>
            <param name="code"></param>
            <param name="message"></param>
            <param name="data"></param>
        </member>
        <member name="M:CryptoExchange.Net.Objects.WebError.#ctor(System.Nullable{System.Int32},System.String,System.Object)">
            <summary>
            ctor
            </summary>
            <param name="code"></param>
            <param name="message"></param>
            <param name="data"></param>
        </member>
        <member name="T:CryptoExchange.Net.Objects.DeserializeError">
            <summary>
            Error while deserializing data
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.Objects.DeserializeError.#ctor(System.String,System.Object)">
            <summary>
            ctor
            </summary>
            <param name="message">The error message</param>
            <param name="data">The data which caused the error</param>
        </member>
        <member name="M:CryptoExchange.Net.Objects.DeserializeError.#ctor(System.Nullable{System.Int32},System.String,System.Object)">
            <summary>
            ctor
            </summary>
            <param name="code"></param>
            <param name="message"></param>
            <param name="data"></param>
        </member>
        <member name="T:CryptoExchange.Net.Objects.UnknownError">
            <summary>
            Unknown error
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.Objects.UnknownError.#ctor(System.String,System.Object)">
            <summary>
            ctor
            </summary>
            <param name="message">Error message</param>
            <param name="data">Error data</param>
        </member>
        <member name="M:CryptoExchange.Net.Objects.UnknownError.#ctor(System.Nullable{System.Int32},System.String,System.Object)">
            <summary>
            ctor
            </summary>
            <param name="code"></param>
            <param name="message"></param>
            <param name="data"></param>
        </member>
        <member name="T:CryptoExchange.Net.Objects.ArgumentError">
            <summary>
            An invalid parameter has been provided
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.Objects.ArgumentError.#ctor(System.String)">
            <summary>
            ctor
            </summary>
            <param name="message"></param>
        </member>
        <member name="M:CryptoExchange.Net.Objects.ArgumentError.#ctor(System.Nullable{System.Int32},System.String,System.Object)">
            <summary>
            ctor
            </summary>
            <param name="code"></param>
            <param name="message"></param>
            <param name="data"></param>
        </member>
        <member name="T:CryptoExchange.Net.Objects.BaseRateLimitError">
            <summary>
            Rate limit exceeded (client side)
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Objects.BaseRateLimitError.RetryAfter">
            <summary>
            When the request can be retried
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.Objects.BaseRateLimitError.#ctor(System.Nullable{System.Int32},System.String,System.Object)">
            <summary>
            ctor
            </summary>
            <param name="code"></param>
            <param name="message"></param>
            <param name="data"></param>
        </member>
        <member name="T:CryptoExchange.Net.Objects.ClientRateLimitError">
            <summary>
            Rate limit exceeded (client side)
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.Objects.ClientRateLimitError.#ctor(System.String)">
            <summary>
            ctor
            </summary>
            <param name="message"></param>
        </member>
        <member name="M:CryptoExchange.Net.Objects.ClientRateLimitError.#ctor(System.Nullable{System.Int32},System.String,System.Object)">
            <summary>
            ctor
            </summary>
            <param name="code"></param>
            <param name="message"></param>
            <param name="data"></param>
        </member>
        <member name="T:CryptoExchange.Net.Objects.ServerRateLimitError">
            <summary>
            Rate limit exceeded (server side)
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.Objects.ServerRateLimitError.#ctor(System.String)">
            <summary>
            ctor
            </summary>
            <param name="message"></param>
        </member>
        <member name="M:CryptoExchange.Net.Objects.ServerRateLimitError.#ctor(System.Nullable{System.Int32},System.String,System.Object)">
            <summary>
            ctor
            </summary>
            <param name="code"></param>
            <param name="message"></param>
            <param name="data"></param>
        </member>
        <member name="T:CryptoExchange.Net.Objects.CancellationRequestedError">
            <summary>
            Cancellation requested
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.Objects.CancellationRequestedError.#ctor">
            <summary>
            ctor
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.Objects.CancellationRequestedError.#ctor(System.Nullable{System.Int32},System.String,System.Object)">
            <summary>
            ctor
            </summary>
            <param name="code"></param>
            <param name="message"></param>
            <param name="data"></param>
        </member>
        <member name="T:CryptoExchange.Net.Objects.InvalidOperationError">
            <summary>
            Invalid operation requested
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.Objects.InvalidOperationError.#ctor(System.String)">
            <summary>
            ctor
            </summary>
            <param name="message"></param>
        </member>
        <member name="M:CryptoExchange.Net.Objects.InvalidOperationError.#ctor(System.Nullable{System.Int32},System.String,System.Object)">
            <summary>
            ctor
            </summary>
            <param name="code"></param>
            <param name="message"></param>
            <param name="data"></param>
        </member>
        <member name="T:CryptoExchange.Net.Objects.Options.ApiOptions">
            <summary>
            Options for API usage
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Objects.Options.ApiOptions.OutputOriginalData">
            <summary>
            If true, the CallResult and DataEvent objects will also include the originally received json data in the OriginalData property
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Objects.Options.ApiOptions.ApiCredentials">
            <summary>
            The api credentials used for signing requests to this API. Overrides API credentials provided in the client options
            </summary>        
        </member>
        <member name="T:CryptoExchange.Net.Objects.Options.ExchangeOptions">
            <summary>
            Exchange options
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Objects.Options.ExchangeOptions.Proxy">
            <summary>
            Proxy settings
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Objects.Options.ExchangeOptions.OutputOriginalData">
            <summary>
            If true, the CallResult and DataEvent objects will also include the originally received json data in the OriginalData property
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Objects.Options.ExchangeOptions.RequestTimeout">
            <summary>
            The max time a request is allowed to take
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Objects.Options.ExchangeOptions.ApiCredentials">
            <summary>
            The api credentials used for signing requests to this API.
            </summary>        
        </member>
        <member name="P:CryptoExchange.Net.Objects.Options.ExchangeOptions.RateLimiterEnabled">
            <summary>
            Whether or not client side rate limiting should be applied
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Objects.Options.ExchangeOptions.RateLimitingBehaviour">
            <summary>
            What should happen when a rate limit is reached
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.Objects.Options.ExchangeOptions.ToString">
            <inheritdoc />
        </member>
        <member name="T:CryptoExchange.Net.Objects.Options.OrderBookOptions">
            <summary>
            Base for order book options
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Objects.Options.OrderBookOptions.ChecksumValidationEnabled">
            <summary>
            Whether or not checksum validation is enabled. Default is true, disabling will ignore checksum messages.
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.Objects.Options.OrderBookOptions.Copy``1">
            <summary>
            Create a copy of this options
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="T:CryptoExchange.Net.Objects.Options.RestApiOptions">
            <summary>
            Http api options
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Objects.Options.RestApiOptions.AutoTimestamp">
            <summary>
            Whether or not to automatically sync the local time with the server time
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Objects.Options.RestApiOptions.TimestampRecalculationInterval">
            <summary>
            How often the timestamp adjustment between client and server is recalculated. If you need a very small TimeSpan here you're probably better of syncing your server time more often
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.Objects.Options.RestApiOptions.Copy``1">
            <summary>
            Create a copy of this options
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="T:CryptoExchange.Net.Objects.Options.RestApiOptions`1">
            <summary>
            Http API options
            </summary>
            <typeparam name="TApiCredentials"></typeparam>
        </member>
        <member name="P:CryptoExchange.Net.Objects.Options.RestApiOptions`1.ApiCredentials">
            <summary>
            The api credentials used for signing requests to this API.
            </summary>
        </member>
        <member name="T:CryptoExchange.Net.Objects.Options.RestExchangeOptions">
            <summary>
            Options for a rest exchange client
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Objects.Options.RestExchangeOptions.AutoTimestamp">
            <summary>
            Whether or not to automatically sync the local time with the server time
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Objects.Options.RestExchangeOptions.TimestampRecalculationInterval">
            <summary>
            How often the timestamp adjustment between client and server is recalculated. If you need a very small TimeSpan here you're probably better of syncing your server time more often
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.Objects.Options.RestExchangeOptions.Copy``1">
            <summary>
            Create a copy of this options
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="T:CryptoExchange.Net.Objects.Options.RestExchangeOptions`1">
            <summary>
            Options for a rest exchange client
            </summary>
            <typeparam name="TEnvironment"></typeparam>
        </member>
        <member name="P:CryptoExchange.Net.Objects.Options.RestExchangeOptions`1.Environment">
            <summary>
            Trade environment. Contains info about URL's to use to connect to the API. To swap environment select another environment for
            the exhange's environment list or create a custom environment using either `[Exchange]Environment.CreateCustom()` or `[Exchange]Environment.[Environment]`, for example `KucoinEnvironment.TestNet` or `BinanceEnvironment.Live`
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.Objects.Options.RestExchangeOptions`1.Copy``1">
            <summary>
            Create a copy of this options
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="T:CryptoExchange.Net.Objects.Options.RestExchangeOptions`2">
            <summary>
            Options for a rest exchange client
            </summary>
            <typeparam name="TEnvironment"></typeparam>
            <typeparam name="TApiCredentials"></typeparam>
        </member>
        <member name="P:CryptoExchange.Net.Objects.Options.RestExchangeOptions`2.ApiCredentials">
            <summary>
            The api credentials used for signing requests to this API.
            </summary>        
        </member>
        <member name="T:CryptoExchange.Net.Objects.Options.SocketApiOptions">
            <summary>
            Socket api options
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Objects.Options.SocketApiOptions.SocketNoDataTimeout">
            <summary>
            The max time of not receiving any data after which the connection is assumed to be dropped. This can only be used for socket connections where a steady flow of data is expected,
            for example when the server sends intermittent ping requests
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Objects.Options.SocketApiOptions.MaxSocketConnections">
            <summary>
            The max amount of connections to make to the server. Can be used for API's which only allow a certain number of connections. Changing this to a high value might cause issues.
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.Objects.Options.SocketApiOptions.Copy``1">
            <summary>
            Create a copy of this options
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="T:CryptoExchange.Net.Objects.Options.SocketApiOptions`1">
            <summary>
            Socket API options
            </summary>
            <typeparam name="TApiCredentials"></typeparam>
        </member>
        <member name="P:CryptoExchange.Net.Objects.Options.SocketApiOptions`1.ApiCredentials">
            <summary>
            The api credentials used for signing requests to this API.
            </summary>        
        </member>
        <member name="T:CryptoExchange.Net.Objects.Options.SocketExchangeOptions">
            <summary>
            Options for a websocket exchange client
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Objects.Options.SocketExchangeOptions.AutoReconnect">
            <summary>
            Whether or not the socket should automatically reconnect when losing connection
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Objects.Options.SocketExchangeOptions.ReconnectInterval">
            <summary>
            Time to wait between reconnect attempts
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Objects.Options.SocketExchangeOptions.MaxConcurrentResubscriptionsPerSocket">
            <summary>
            Max number of concurrent resubscription tasks per socket after reconnecting a socket
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Objects.Options.SocketExchangeOptions.SocketNoDataTimeout">
            <summary>
            The max time of not receiving any data after which the connection is assumed to be dropped. This can only be used for socket connections where a steady flow of data is expected,
            for example when the server sends intermittent ping requests
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Objects.Options.SocketExchangeOptions.SocketSubscriptionsCombineTarget">
            <summary>
            The amount of subscriptions that should be made on a single socket connection. Not all API's support multiple subscriptions on a single socket.
            Setting this to a higher number increases subscription speed because not every subscription needs to connect to the server, but having more subscriptions on a 
            single connection will also increase the amount of traffic on that single connection, potentially leading to issues.
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Objects.Options.SocketExchangeOptions.MaxSocketConnections">
            <summary>
            The max amount of connections to make to the server. Can be used for API's which only allow a certain number of connections. Changing this to a high value might cause issues.
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Objects.Options.SocketExchangeOptions.DelayAfterConnect">
            <summary>
            The time to wait after connecting a socket before sending messages. Can be used for API's which will rate limit if you subscribe directly after connecting.
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.Objects.Options.SocketExchangeOptions.Copy``1">
            <summary>
            Create a copy of this options
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="T:CryptoExchange.Net.Objects.Options.SocketExchangeOptions`1">
            <summary>
            Options for a socket exchange client
            </summary>
            <typeparam name="TEnvironment"></typeparam>
        </member>
        <member name="P:CryptoExchange.Net.Objects.Options.SocketExchangeOptions`1.Environment">
            <summary>
            Trade environment. Contains info about URL's to use to connect to the API. To swap environment select another environment for
            the exhange's environment list or create a custom environment using either `[Exchange]Environment.CreateCustom()` or `[Exchange]Environment.[Environment]`, for example `KucoinEnvironment.TestNet` or `BinanceEnvironment.Live`
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.Objects.Options.SocketExchangeOptions`1.Copy``1">
            <summary>
            Create a copy of this options
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="T:CryptoExchange.Net.Objects.Options.SocketExchangeOptions`2">
            <summary>
            Options for a socket exchange client
            </summary>
            <typeparam name="TEnvironment"></typeparam>
            <typeparam name="TApiCredentials"></typeparam>
        </member>
        <member name="P:CryptoExchange.Net.Objects.Options.SocketExchangeOptions`2.ApiCredentials">
            <summary>
            The api credentials used for signing requests to this API.
            </summary>        
        </member>
        <member name="T:CryptoExchange.Net.Objects.OrderedStringComparer">
            <summary>
            Order string comparer, sorts by alphabetical order
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.Objects.OrderedStringComparer.Compare(System.String,System.String)">
            <summary>
            Compare function
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <returns></returns>
        </member>
        <member name="T:CryptoExchange.Net.Objects.ParameterCollection">
            <summary>
            Parameters collection
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.Objects.ParameterCollection.AddOptional(System.String,System.Object)">
            <summary>
            Add an optional parameter. Not added if value is null
            </summary>
            <param name="key"></param>
            <param name="value"></param>
        </member>
        <member name="M:CryptoExchange.Net.Objects.ParameterCollection.AddString(System.String,System.Decimal)">
            <summary>
            Add a decimal value as string
            </summary>
            <param name="key"></param>
            <param name="value"></param>
        </member>
        <member name="M:CryptoExchange.Net.Objects.ParameterCollection.AddOptionalString(System.String,System.Nullable{System.Decimal})">
            <summary>
            Add a decimal value as string. Not added if value is null
            </summary>
            <param name="key"></param>
            <param name="value"></param>
        </member>
        <member name="M:CryptoExchange.Net.Objects.ParameterCollection.AddString(System.String,System.Int32)">
            <summary>
            Add a int value as string
            </summary>
            <param name="key"></param>
            <param name="value"></param>
        </member>
        <member name="M:CryptoExchange.Net.Objects.ParameterCollection.AddOptionalString(System.String,System.Nullable{System.Int32})">
            <summary>
            Add a int value as string. Not added if value is null
            </summary>
            <param name="key"></param>
            <param name="value"></param>
        </member>
        <member name="M:CryptoExchange.Net.Objects.ParameterCollection.AddString(System.String,System.Int64)">
            <summary>
            Add a long value as string
            </summary>
            <param name="key"></param>
            <param name="value"></param>
        </member>
        <member name="M:CryptoExchange.Net.Objects.ParameterCollection.AddOptionalString(System.String,System.Nullable{System.Int64})">
            <summary>
            Add a long value as string. Not added if value is null
            </summary>
            <param name="key"></param>
            <param name="value"></param>
        </member>
        <member name="M:CryptoExchange.Net.Objects.ParameterCollection.AddMilliseconds(System.String,System.DateTime)">
            <summary>
            Add a datetime value as milliseconds timestamp
            </summary>
            <param name="key"></param>
            <param name="value"></param>
        </member>
        <member name="M:CryptoExchange.Net.Objects.ParameterCollection.AddOptionalMilliseconds(System.String,System.Nullable{System.DateTime})">
            <summary>
            Add a datetime value as milliseconds timestamp. Not added if value is null
            </summary>
            <param name="key"></param>
            <param name="value"></param>
        </member>
        <member name="M:CryptoExchange.Net.Objects.ParameterCollection.AddMillisecondsString(System.String,System.DateTime)">
            <summary>
            Add a datetime value as milliseconds timestamp
            </summary>
            <param name="key"></param>
            <param name="value"></param>
        </member>
        <member name="M:CryptoExchange.Net.Objects.ParameterCollection.AddOptionalMillisecondsString(System.String,System.Nullable{System.DateTime})">
            <summary>
            Add a datetime value as milliseconds timestamp. Not added if value is null
            </summary>
            <param name="key"></param>
            <param name="value"></param>
        </member>
        <member name="M:CryptoExchange.Net.Objects.ParameterCollection.AddSeconds(System.String,System.DateTime)">
            <summary>
            Add a datetime value as seconds timestamp
            </summary>
            <param name="key"></param>
            <param name="value"></param>
        </member>
        <member name="M:CryptoExchange.Net.Objects.ParameterCollection.AddOptionalSeconds(System.String,System.Nullable{System.DateTime})">
            <summary>
            Add a datetime value as seconds timestamp. Not added if value is null
            </summary>
            <param name="key"></param>
            <param name="value"></param>
        </member>
        <member name="M:CryptoExchange.Net.Objects.ParameterCollection.AddEnum``1(System.String,``0)">
            <summary>
            Add an enum value as the string value as mapped using the <see cref="T:CryptoExchange.Net.Attributes.MapAttribute" />
            </summary>
            <param name="key"></param>
            <param name="value"></param>
        </member>
        <member name="M:CryptoExchange.Net.Objects.ParameterCollection.AddEnumAsInt``1(System.String,``0)">
            <summary>
            Add an enum value as the string value as mapped using the <see cref="T:CryptoExchange.Net.Attributes.MapAttribute" />
            </summary>
            <param name="key"></param>
            <param name="value"></param>
        </member>
        <member name="M:CryptoExchange.Net.Objects.ParameterCollection.AddOptionalEnum``1(System.String,``0)">
            <summary>
            Add an enum value as the string value as mapped using the <see cref="T:CryptoExchange.Net.Attributes.MapAttribute" />. Not added if value is null
            </summary>
            <param name="key"></param>
            <param name="value"></param>
        </member>
        <member name="M:CryptoExchange.Net.Objects.ParameterCollection.AddOptionalEnumAsInt``1(System.String,``0)">
            <summary>
            Add an enum value as the string value as mapped using the <see cref="T:CryptoExchange.Net.Attributes.MapAttribute" />. Not added if value is null
            </summary>
            <param name="key"></param>
            <param name="value"></param>
        </member>
        <member name="T:CryptoExchange.Net.Objects.RequestDefinition">
            <summary>
            The definition of a rest request
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Objects.RequestDefinition.Path">
            <summary>
            Path of the request
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Objects.RequestDefinition.Method">
            <summary>
            Http method of the request
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Objects.RequestDefinition.Authenticated">
            <summary>
            Is the request authenticated
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Objects.RequestDefinition.RequestBodyFormat">
            <summary>
            The body format for this request
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Objects.RequestDefinition.ParameterPosition">
            <summary>
            The position of parameters for this request
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Objects.RequestDefinition.ArraySerialization">
            <summary>
            The array serialization type for this request
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Objects.RequestDefinition.Weight">
            <summary>
            Request weight
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Objects.RequestDefinition.RateLimitGate">
            <summary>
            Rate limit gate to use
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Objects.RequestDefinition.EndpointLimitCount">
            <summary>
            Rate limit for this specific endpoint
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Objects.RequestDefinition.EndpointLimitPeriod">
            <summary>
            Rate limit period for this specific endpoint
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.Objects.RequestDefinition.#ctor(System.String,System.Net.Http.HttpMethod)">
            <summary>
            ctor
            </summary>
            <param name="path"></param>
            <param name="method"></param>
        </member>
        <member name="M:CryptoExchange.Net.Objects.RequestDefinition.ToString">
            <inheritdoc />
        </member>
        <member name="T:CryptoExchange.Net.Objects.RequestDefinitionCache">
            <summary>
            Request definitions cache
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.Objects.RequestDefinitionCache.GetOrCreate(System.Net.Http.HttpMethod,System.String,System.Boolean)">
            <summary>
            Get a definition if it is already in the cache or create a new definition and add it to the cache
            </summary>
            <param name="method">The HttpMethod</param>
            <param name="path">Endpoint path</param>
            <param name="authenticated">Endpoint is authenticated</param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Objects.RequestDefinitionCache.GetOrCreate(System.Net.Http.HttpMethod,System.String,CryptoExchange.Net.RateLimiting.Interfaces.IRateLimitGate,System.Int32,System.Boolean)">
            <summary>
            Get a definition if it is already in the cache or create a new definition and add it to the cache
            </summary>
            <param name="method">The HttpMethod</param>
            <param name="path">Endpoint path</param>
            <param name="rateLimitGate">The rate limit gate</param>
            <param name="weight">Request weight</param>
            <param name="authenticated">Endpoint is authenticated</param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Objects.RequestDefinitionCache.GetOrCreate(System.Net.Http.HttpMethod,System.String,CryptoExchange.Net.RateLimiting.Interfaces.IRateLimitGate,System.Int32,System.Boolean,System.Nullable{System.Int32},System.Nullable{System.TimeSpan},System.Nullable{CryptoExchange.Net.Objects.RequestBodyFormat},System.Nullable{CryptoExchange.Net.Objects.HttpMethodParameterPosition},System.Nullable{CryptoExchange.Net.Objects.ArrayParametersSerialization})">
            <summary>
            Get a definition if it is already in the cache or create a new definition and add it to the cache
            </summary>
            <param name="method">The HttpMethod</param>
            <param name="path">Endpoint path</param>
            <param name="rateLimitGate">The rate limit gate</param>
            <param name="endpointLimitCount">The limit count for this specific endpoint</param>
            <param name="endpointLimitPeriod">The period for the limit for this specific endpoint</param>
            <param name="weight">Request weight</param>
            <param name="authenticated">Endpoint is authenticated</param>
            <param name="requestBodyFormat">Request body format</param>
            <param name="parameterPosition">Parameter position</param>
            <param name="arraySerialization">Array serialization type</param>
            <returns></returns>
        </member>
        <member name="T:CryptoExchange.Net.Objects.Sockets.DataEvent`1">
            <summary>
            An update received from a socket update subscription
            </summary>
            <typeparam name="T">The type of the data</typeparam>
        </member>
        <member name="P:CryptoExchange.Net.Objects.Sockets.DataEvent`1.Timestamp">
            <summary>
            The timestamp the data was received
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Objects.Sockets.DataEvent`1.Topic">
            <summary>
            The topic of the update, what symbol/asset etc..
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Objects.Sockets.DataEvent`1.OriginalData">
            <summary>
            The original data that was received, only available when OutputOriginalData is set to true in the client options
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Objects.Sockets.DataEvent`1.UpdateType">
            <summary>
            Type of update
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Objects.Sockets.DataEvent`1.Data">
            <summary>
            The received data deserialized into an object
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.Objects.Sockets.DataEvent`1.As``1(``0)">
            <summary>
            Create a new DataEvent with data in the from of type K based on the current DataEvent. Topic, OriginalData and Timestamp will be copied over
            </summary>
            <typeparam name="K">The type of the new data</typeparam>
            <param name="data">The new data</param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Objects.Sockets.DataEvent`1.As``1(``0,System.String)">
            <summary>
            Create a new DataEvent with data in the from of type K based on the current DataEvent. OriginalData and Timestamp will be copied over
            </summary>
            <typeparam name="K">The type of the new data</typeparam>
            <param name="data">The new data</param>
            <param name="topic">The new topic</param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Objects.Sockets.DataEvent`1.As``1(``0,System.String,CryptoExchange.Net.Objects.SocketUpdateType)">
            <summary>
            Create a new DataEvent with data in the from of type K based on the current DataEvent. OriginalData and Timestamp will be copied over
            </summary>
            <typeparam name="K">The type of the new data</typeparam>
            <param name="data">The new data</param>
            <param name="topic">The new topic</param>
            <param name="updateType">The type of update</param>
            <returns></returns>
        </member>
        <member name="T:CryptoExchange.Net.Objects.Sockets.UpdateSubscription">
            <summary>
            Subscription to a data stream
            </summary>
        </member>
        <member name="E:CryptoExchange.Net.Objects.Sockets.UpdateSubscription.ConnectionLost">
            <summary>
            Event when the connection is lost. The socket will automatically reconnect when possible.
            </summary>
        </member>
        <member name="E:CryptoExchange.Net.Objects.Sockets.UpdateSubscription.ConnectionClosed">
            <summary>
            Event when the connection is closed and will not be reconnected
            </summary>
        </member>
        <member name="E:CryptoExchange.Net.Objects.Sockets.UpdateSubscription.ConnectionRestored">
            <summary>
            Event when the connection is restored. Timespan parameter indicates the time the socket has been offline for before reconnecting. 
            Note that when the executing code is suspended and resumed at a later period (for example, a laptop going to sleep) the disconnect time will be incorrect as the diconnect
            will only be detected after resuming the code, so the initial disconnect time is lost. Use the timespan only for informational purposes.
            </summary>
        </member>
        <member name="E:CryptoExchange.Net.Objects.Sockets.UpdateSubscription.ActivityPaused">
            <summary>
            Event when the connection to the server is paused based on a server indication. No operations can be performed while paused
            </summary>
        </member>
        <member name="E:CryptoExchange.Net.Objects.Sockets.UpdateSubscription.ActivityUnpaused">
            <summary>
            Event when the connection to the server is unpaused after being paused
            </summary>
        </member>
        <member name="E:CryptoExchange.Net.Objects.Sockets.UpdateSubscription.Exception">
            <summary>
            Event when an exception happens during the handling of the data
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Objects.Sockets.UpdateSubscription.SocketId">
            <summary>
            The id of the socket
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Objects.Sockets.UpdateSubscription.Id">
            <summary>
            The id of the subscription
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.Objects.Sockets.UpdateSubscription.#ctor(CryptoExchange.Net.Sockets.SocketConnection,CryptoExchange.Net.Sockets.Subscription)">
            <summary>
            ctor
            </summary>
            <param name="connection">The socket connection the subscription is on</param>
            <param name="subscription">The subscription</param>
        </member>
        <member name="M:CryptoExchange.Net.Objects.Sockets.UpdateSubscription.CloseAsync">
            <summary>
            Close the subscription
            </summary>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Objects.Sockets.UpdateSubscription.ReconnectAsync">
            <summary>
            Close the socket to cause a reconnect
            </summary>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Objects.Sockets.UpdateSubscription.UnsubscribeAsync">
            <summary>
            Unsubscribe a subscription
            </summary>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Objects.Sockets.UpdateSubscription.ResubscribeAsync">
            <summary>
            Resubscribe this subscription
            </summary>
            <returns></returns>
        </member>
        <member name="T:CryptoExchange.Net.Objects.Sockets.WebSocketParameters">
            <summary>
            Parameters for a websocket
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Objects.Sockets.WebSocketParameters.Uri">
            <summary>
            The uri to connect to
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Objects.Sockets.WebSocketParameters.Headers">
            <summary>
            Headers to send in the connection handshake
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Objects.Sockets.WebSocketParameters.Cookies">
            <summary>
            Cookies to send in the connection handshake
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Objects.Sockets.WebSocketParameters.ReconnectInterval">
            <summary>
            The time to wait between reconnect attempts
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Objects.Sockets.WebSocketParameters.Proxy">
            <summary>
            Proxy for the connection
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Objects.Sockets.WebSocketParameters.AutoReconnect">
            <summary>
            Whether the socket should automatically reconnect when connection is lost
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Objects.Sockets.WebSocketParameters.Timeout">
            <summary>
            The maximum time of no data received before considering the connection lost and closting/reconnecting the socket
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Objects.Sockets.WebSocketParameters.KeepAliveInterval">
            <summary>
            Interval at which to send ping frames
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Objects.Sockets.WebSocketParameters.RateLimiter">
            <summary>
            The rate limiter for the socket connection
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Objects.Sockets.WebSocketParameters.RateLimitingBehaviour">
            <summary>
            What to do when rate limit is reached
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Objects.Sockets.WebSocketParameters.Encoding">
            <summary>
            Encoding for sending/receiving data
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.Objects.Sockets.WebSocketParameters.#ctor(System.Uri,System.Boolean)">
            <summary>
            ctor
            </summary>
            <param name="uri">Uri</param>
            <param name="autoReconnect">Auto reconnect</param>
        </member>
        <member name="T:CryptoExchange.Net.Objects.TimeSyncState">
            <summary>
            The time synchronization state of an API client
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Objects.TimeSyncState.ApiName">
            <summary>
            Name of the API
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Objects.TimeSyncState.Semaphore">
            <summary>
            Semaphore to use for checking the time syncing. Should be shared instance among the API client
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Objects.TimeSyncState.LastSyncTime">
            <summary>
            Last sync time for the API client
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Objects.TimeSyncState.TimeOffset">
            <summary>
            Time offset for the API client
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.Objects.TimeSyncState.#ctor(System.String)">
            <summary>
            ctor
            </summary>
        </member>
        <member name="T:CryptoExchange.Net.Objects.TimeSyncInfo">
            <summary>
            Time synchronization info
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Objects.TimeSyncInfo.Logger">
            <summary>
            Logger
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Objects.TimeSyncInfo.SyncTime">
            <summary>
            Should synchronize time
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Objects.TimeSyncInfo.RecalculationInterval">
            <summary>
            Timestamp recalulcation interval
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Objects.TimeSyncInfo.TimeSyncState">
            <summary>
            Time sync state for the API client
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.Objects.TimeSyncInfo.#ctor(Microsoft.Extensions.Logging.ILogger,System.Boolean,System.TimeSpan,CryptoExchange.Net.Objects.TimeSyncState)">
            <summary>
            ctor
            </summary>
            <param name="logger"></param>
            <param name="recalculationInterval"></param>
            <param name="syncTime"></param>
            <param name="syncState"></param>
        </member>
        <member name="M:CryptoExchange.Net.Objects.TimeSyncInfo.UpdateTimeOffset(System.TimeSpan)">
            <summary>
            Set the time offset
            </summary>
            <param name="offset"></param>
        </member>
        <member name="T:CryptoExchange.Net.Objects.TraceLoggerProvider">
            <summary>
            Trace logger provider for creating trace loggers
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.Objects.TraceLoggerProvider.#ctor(System.Nullable{Microsoft.Extensions.Logging.LogLevel})">
            <summary>
            ctor
            </summary>
            <param name="logLevel"></param>
        </member>
        <member name="M:CryptoExchange.Net.Objects.TraceLoggerProvider.CreateLogger(System.String)">
            <inheritdoc />
        </member>
        <member name="M:CryptoExchange.Net.Objects.TraceLoggerProvider.Dispose">
            <inheritdoc />
        </member>
        <member name="T:CryptoExchange.Net.Objects.TraceLogger">
            <summary>
            Trace logger
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.Objects.TraceLogger.#ctor(System.String,Microsoft.Extensions.Logging.LogLevel)">
            <summary>
            ctor
            </summary>
            <param name="categoryName"></param>
            <param name="level"></param>
        </member>
        <member name="M:CryptoExchange.Net.Objects.TraceLogger.BeginScope``1(``0)">
            <inheritdoc />
        </member>
        <member name="M:CryptoExchange.Net.Objects.TraceLogger.IsEnabled(Microsoft.Extensions.Logging.LogLevel)">
            <inheritdoc />
        </member>
        <member name="M:CryptoExchange.Net.Objects.TraceLogger.Log``1(Microsoft.Extensions.Logging.LogLevel,Microsoft.Extensions.Logging.EventId,``0,System.Exception,System.Func{``0,System.Exception,System.String})">
            <inheritdoc />
        </member>
        <member name="T:CryptoExchange.Net.Objects.TradeEnvironmentNames">
            <summary>
            Trade environment names
            </summary>
        </member>
        <member name="F:CryptoExchange.Net.Objects.TradeEnvironmentNames.Live">
            <summary>
            Live environment
            </summary>
        </member>
        <member name="F:CryptoExchange.Net.Objects.TradeEnvironmentNames.Testnet">
            <summary>
            Testnet environment
            </summary>
        </member>
        <member name="T:CryptoExchange.Net.Objects.TradeEnvironment">
            <summary>
            Trade environment. Contains info about URL's to use to connect to the API. To swap environment select another environment for
            the echange's environment list or create a custom environment using either `[Exchange]Environment.CreateCustom()` or `[Exchange]Environment.[Environment]`, for example `KucoinEnvironment.TestNet` or `BinanceEnvironment.Live`
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Objects.TradeEnvironment.EnvironmentName">
            <summary>
            Name of the environment
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.Objects.TradeEnvironment.#ctor(System.String)">
            <summary>
            </summary>
            <param name="name"></param>
        </member>
        <member name="T:CryptoExchange.Net.OrderBook.OrderBookFactory`1">
            <inheritdoc />
        </member>
        <member name="M:CryptoExchange.Net.OrderBook.OrderBookFactory`1.#ctor(System.Func{System.String,System.Action{`0},CryptoExchange.Net.Interfaces.ISymbolOrderBook},System.Func{System.String,System.String,System.Action{`0},CryptoExchange.Net.Interfaces.ISymbolOrderBook})">
            <summary>
            ctor
            </summary>
            <param name="symbolCtor"></param>
            <param name="assetsCtor"></param>
        </member>
        <member name="M:CryptoExchange.Net.OrderBook.OrderBookFactory`1.Create(System.String,System.Action{`0})">
            <inheritdoc />
        </member>
        <member name="M:CryptoExchange.Net.OrderBook.OrderBookFactory`1.Create(System.String,System.String,System.Action{`0})">
            <inheritdoc />
        </member>
        <member name="T:CryptoExchange.Net.OrderBook.ProcessBufferRangeSequenceEntry">
            <summary>
            Buffer entry with a first and last update id
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.OrderBook.ProcessBufferRangeSequenceEntry.FirstUpdateId">
            <summary>
            First sequence number in this update
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.OrderBook.ProcessBufferRangeSequenceEntry.LastUpdateId">
            <summary>
            Last sequence number in this update
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.OrderBook.ProcessBufferRangeSequenceEntry.Asks">
            <summary>
            List of changed/new asks
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.OrderBook.ProcessBufferRangeSequenceEntry.Bids">
            <summary>
            List of changed/new bids
            </summary>
        </member>
        <member name="T:CryptoExchange.Net.OrderBook.SymbolOrderBook">
            <summary>
            Base for order book implementations
            </summary>
        </member>
        <member name="F:CryptoExchange.Net.OrderBook.SymbolOrderBook._processBuffer">
            <summary>
            A buffer to store messages received before the initial book snapshot is processed. These messages
            will be processed after the book snapshot is set. Any messages in this buffer with sequence numbers lower
            than the snapshot sequence number will be discarded
            </summary>
        </member>
        <member name="F:CryptoExchange.Net.OrderBook.SymbolOrderBook._asks">
            <summary>
            The ask list, should only be accessed using the bookLock
            </summary>
        </member>
        <member name="F:CryptoExchange.Net.OrderBook.SymbolOrderBook._bids">
            <summary>
            The bid list, should only be accessed using the bookLock
            </summary>
        </member>
        <member name="F:CryptoExchange.Net.OrderBook.SymbolOrderBook._logger">
            <summary>
            The log
            </summary>
        </member>
        <member name="F:CryptoExchange.Net.OrderBook.SymbolOrderBook._sequencesAreConsecutive">
            <summary>
            Whether update numbers are consecutive. If set to true and an update comes in which isn't the previous sequences number + 1
            the book will resynchronize as it is deemed out of sync
            </summary>
        </member>
        <member name="F:CryptoExchange.Net.OrderBook.SymbolOrderBook._strictLevels">
            <summary>
            Whether levels should be strictly enforced. For example, when an order book has 25 levels and a new update comes in which pushes
            the current level 25 ask out of the top 25, should the curent the level 26 entry be removed from the book or does the 
            server handle this
            </summary>
        </member>
        <member name="F:CryptoExchange.Net.OrderBook.SymbolOrderBook._bookSet">
            <summary>
            If the initial snapshot of the book has been set
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.OrderBook.SymbolOrderBook.Levels">
            <summary>
            The amount of levels for this book
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.OrderBook.SymbolOrderBook.Exchange">
            <inheritdoc/>
        </member>
        <member name="P:CryptoExchange.Net.OrderBook.SymbolOrderBook.Api">
            <inheritdoc/>
        </member>
        <member name="P:CryptoExchange.Net.OrderBook.SymbolOrderBook.Status">
            <inheritdoc/>
        </member>
        <member name="P:CryptoExchange.Net.OrderBook.SymbolOrderBook.LastSequenceNumber">
            <inheritdoc/>
        </member>
        <member name="P:CryptoExchange.Net.OrderBook.SymbolOrderBook.Symbol">
            <inheritdoc/>
        </member>
        <member name="E:CryptoExchange.Net.OrderBook.SymbolOrderBook.OnStatusChange">
            <inheritdoc/>
        </member>
        <member name="E:CryptoExchange.Net.OrderBook.SymbolOrderBook.OnBestOffersChanged">
            <inheritdoc/>
        </member>
        <member name="E:CryptoExchange.Net.OrderBook.SymbolOrderBook.OnOrderBookUpdate">
            <inheritdoc/>
        </member>
        <member name="P:CryptoExchange.Net.OrderBook.SymbolOrderBook.UpdateTime">
            <inheritdoc/>
        </member>
        <member name="P:CryptoExchange.Net.OrderBook.SymbolOrderBook.AskCount">
            <inheritdoc/>
        </member>
        <member name="P:CryptoExchange.Net.OrderBook.SymbolOrderBook.BidCount">
            <inheritdoc/>
        </member>
        <member name="P:CryptoExchange.Net.OrderBook.SymbolOrderBook.Asks">
            <inheritdoc/>
        </member>
        <member name="P:CryptoExchange.Net.OrderBook.SymbolOrderBook.Bids">
            <inheritdoc/>
        </member>
        <member name="P:CryptoExchange.Net.OrderBook.SymbolOrderBook.Book">
            <inheritdoc/>
        </member>
        <member name="P:CryptoExchange.Net.OrderBook.SymbolOrderBook.BestBid">
            <inheritdoc/>
        </member>
        <member name="P:CryptoExchange.Net.OrderBook.SymbolOrderBook.BestAsk">
            <inheritdoc/>
        </member>
        <member name="P:CryptoExchange.Net.OrderBook.SymbolOrderBook.BestOffers">
            <inheritdoc/>
        </member>
        <member name="M:CryptoExchange.Net.OrderBook.SymbolOrderBook.#ctor(Microsoft.Extensions.Logging.ILoggerFactory,System.String,System.String,System.String)">
            <summary>
            ctor
            </summary>
            <param name="logger">Logger to use. If not provided will create a TraceLogger</param>
            <param name="exchange">The exchange of the order book</param>
            <param name="api">The API the book is for, for example Spot</param>
            <param name="symbol">The symbol the order book is for</param>
        </member>
        <member name="M:CryptoExchange.Net.OrderBook.SymbolOrderBook.Initialize(CryptoExchange.Net.Objects.Options.OrderBookOptions)">
            <summary>
            Initialize the order book using the provided options
            </summary>
            <param name="options">The options</param>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:CryptoExchange.Net.OrderBook.SymbolOrderBook.StartAsync(System.Nullable{System.Threading.CancellationToken})">
            <inheritdoc/>
        </member>
        <member name="M:CryptoExchange.Net.OrderBook.SymbolOrderBook.StopAsync">
            <inheritdoc/>
        </member>
        <member name="M:CryptoExchange.Net.OrderBook.SymbolOrderBook.CalculateAverageFillPrice(System.Decimal,CryptoExchange.Net.Objects.OrderBookEntryType)">
            <inheritdoc/>
        </member>
        <member name="M:CryptoExchange.Net.OrderBook.SymbolOrderBook.CalculateTradableAmount(System.Decimal,CryptoExchange.Net.Objects.OrderBookEntryType)">
            <inheritdoc/>
        </member>
        <member name="M:CryptoExchange.Net.OrderBook.SymbolOrderBook.DoStartAsync(System.Threading.CancellationToken)">
            <summary>
            Implementation for starting the order book. Should typically have logic for subscribing to the update stream and retrieving
            and setting the initial order book
            </summary>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.OrderBook.SymbolOrderBook.DoReset">
            <summary>
            Reset the order book
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.OrderBook.SymbolOrderBook.DoResyncAsync(System.Threading.CancellationToken)">
            <summary>
            Resync the order book
            </summary>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.OrderBook.SymbolOrderBook.DoChecksum(System.Int32)">
            <summary>
            Implementation for validating a checksum value with the current order book. If checksum validation fails (returns false)
            the order book will be resynchronized
            </summary>
            <param name="checksum"></param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.OrderBook.SymbolOrderBook.SetInitialOrderBook(System.Int64,System.Collections.Generic.IEnumerable{CryptoExchange.Net.Interfaces.ISymbolOrderBookEntry},System.Collections.Generic.IEnumerable{CryptoExchange.Net.Interfaces.ISymbolOrderBookEntry})">
            <summary>
            Set the initial data for the order book. Typically the snapshot which was requested from the Rest API, or the first snapshot
            received from a socket subcription
            </summary>
            <param name="orderBookSequenceNumber">The last update sequence number until which the snapshot is in sync</param>
            <param name="askList">List of asks</param>
            <param name="bidList">List of bids</param>
        </member>
        <member name="M:CryptoExchange.Net.OrderBook.SymbolOrderBook.UpdateOrderBook(System.Int64,System.Collections.Generic.IEnumerable{CryptoExchange.Net.Interfaces.ISymbolOrderBookEntry},System.Collections.Generic.IEnumerable{CryptoExchange.Net.Interfaces.ISymbolOrderBookEntry})">
            <summary>
            Add an update to the process queue. Updates the book by providing changed bids and asks, along with an update number which should be higher than the previous update numbers
            </summary>
            <param name="updateId">The sequence number</param>
            <param name="bids">List of updated/new bids</param>
            <param name="asks">List of updated/new asks</param>
        </member>
        <member name="M:CryptoExchange.Net.OrderBook.SymbolOrderBook.UpdateOrderBook(System.Int64,System.Int64,System.Collections.Generic.IEnumerable{CryptoExchange.Net.Interfaces.ISymbolOrderBookEntry},System.Collections.Generic.IEnumerable{CryptoExchange.Net.Interfaces.ISymbolOrderBookEntry})">
            <summary>
            Add an update to the process queue. Updates the book by providing changed bids and asks, along with the first and last sequence number in the update
            </summary>
            <param name="firstUpdateId">The sequence number of the first update</param>
            <param name="lastUpdateId">The sequence number of the last update</param>
            <param name="bids">List of updated/new bids</param>
            <param name="asks">List of updated/new asks</param>
        </member>
        <member name="M:CryptoExchange.Net.OrderBook.SymbolOrderBook.UpdateOrderBook(System.Collections.Generic.IEnumerable{CryptoExchange.Net.Interfaces.ISymbolOrderSequencedBookEntry},System.Collections.Generic.IEnumerable{CryptoExchange.Net.Interfaces.ISymbolOrderSequencedBookEntry})">
            <summary>
            Add an update to the process queue. Updates the book by providing changed bids and asks, each with its own sequence number
            </summary>
            <param name="bids">List of updated/new bids</param>
            <param name="asks">List of updated/new asks</param>
        </member>
        <member name="M:CryptoExchange.Net.OrderBook.SymbolOrderBook.AddChecksum(System.Int32)">
            <summary>
            Add a checksum value to the process queue
            </summary>
            <param name="checksum">The checksum value</param>
        </member>
        <member name="M:CryptoExchange.Net.OrderBook.SymbolOrderBook.CheckProcessBuffer">
            <summary>
            Check and empty the process buffer; see what entries to update the book with
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.OrderBook.SymbolOrderBook.ProcessUpdate(System.Int64,CryptoExchange.Net.Objects.OrderBookEntryType,CryptoExchange.Net.Interfaces.ISymbolOrderBookEntry)">
            <summary>
            Update order book with an entry
            </summary>
            <param name="sequence">Sequence number of the update</param>
            <param name="type">Type of entry</param>
            <param name="entry">The entry</param>
        </member>
        <member name="M:CryptoExchange.Net.OrderBook.SymbolOrderBook.WaitForSetOrderBookAsync(System.TimeSpan,System.Threading.CancellationToken)">
            <summary>
            Wait until the order book snapshot has been set
            </summary>
            <param name="timeout">Max wait time</param>
            <param name="ct">Cancellation token</param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.OrderBook.SymbolOrderBook.Dispose">
            <summary>
            IDisposable implementation for the order book
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.OrderBook.SymbolOrderBook.Dispose(System.Boolean)">
            <summary>
            Dispose method
            </summary>
            <param name="disposing"></param>
        </member>
        <member name="M:CryptoExchange.Net.OrderBook.SymbolOrderBook.ToString">
            <summary>
            String representation of the top 3 entries
            </summary>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.OrderBook.SymbolOrderBook.ToString(System.Int32)">
            <summary>
            String representation of the top x entries
            </summary>
            <returns></returns>
        </member>
        <member name="T:CryptoExchange.Net.RateLimiting.Filters.AuthenticatedEndpointFilter">
            <summary>
            Filter requests based on whether they're authenticated or not
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.RateLimiting.Filters.AuthenticatedEndpointFilter.#ctor(System.Boolean)">
            <summary>
            ctor
            </summary>
            <param name="authenticated"></param>
        </member>
        <member name="M:CryptoExchange.Net.RateLimiting.Filters.AuthenticatedEndpointFilter.Passes(CryptoExchange.Net.RateLimiting.RateLimitItemType,CryptoExchange.Net.Objects.RequestDefinition,System.String,System.Security.SecureString)">
            <inheritdoc />
        </member>
        <member name="T:CryptoExchange.Net.RateLimiting.Filters.ExactPathFilter">
            <summary>
            Filter requests based on whether the request path matches a specific path
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.RateLimiting.Filters.ExactPathFilter.#ctor(System.String)">
            <summary>
            ctor
            </summary>
            <param name="path"></param>
        </member>
        <member name="M:CryptoExchange.Net.RateLimiting.Filters.ExactPathFilter.Passes(CryptoExchange.Net.RateLimiting.RateLimitItemType,CryptoExchange.Net.Objects.RequestDefinition,System.String,System.Security.SecureString)">
            <inheritdoc />
        </member>
        <member name="T:CryptoExchange.Net.RateLimiting.Filters.ExactPathsFilter">
            <summary>
            Filter requests based on whether the request path matches any specific path in a list
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.RateLimiting.Filters.ExactPathsFilter.#ctor(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            ctor
            </summary>
            <param name="paths"></param>
        </member>
        <member name="M:CryptoExchange.Net.RateLimiting.Filters.ExactPathsFilter.Passes(CryptoExchange.Net.RateLimiting.RateLimitItemType,CryptoExchange.Net.Objects.RequestDefinition,System.String,System.Security.SecureString)">
            <inheritdoc />
        </member>
        <member name="T:CryptoExchange.Net.RateLimiting.Filters.HostFilter">
            <summary>
            Filter requests based on whether the host address matches a specific address
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.RateLimiting.Filters.HostFilter.#ctor(System.String)">
            <summary>
            ctor
            </summary>
            <param name="host"></param>
        </member>
        <member name="M:CryptoExchange.Net.RateLimiting.Filters.HostFilter.Passes(CryptoExchange.Net.RateLimiting.RateLimitItemType,CryptoExchange.Net.Objects.RequestDefinition,System.String,System.Security.SecureString)">
            <inheritdoc />
        </member>
        <member name="T:CryptoExchange.Net.RateLimiting.Filters.LimitItemTypeFilter">
            <summary>
            Filter requests based on whether it's a connection or a request
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.RateLimiting.Filters.LimitItemTypeFilter.#ctor(CryptoExchange.Net.RateLimiting.RateLimitItemType)">
            <summary>
            ctor
            </summary>
            <param name="type"></param>
        </member>
        <member name="M:CryptoExchange.Net.RateLimiting.Filters.LimitItemTypeFilter.Passes(CryptoExchange.Net.RateLimiting.RateLimitItemType,CryptoExchange.Net.Objects.RequestDefinition,System.String,System.Security.SecureString)">
            <inheritdoc />
        </member>
        <member name="T:CryptoExchange.Net.RateLimiting.Filters.PathStartFilter">
            <summary>
            Filter requests based on whether the path starts with a specific string
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.RateLimiting.Filters.PathStartFilter.#ctor(System.String)">
            <summary>
            ctor
            </summary>
            <param name="path"></param>
        </member>
        <member name="M:CryptoExchange.Net.RateLimiting.Filters.PathStartFilter.Passes(CryptoExchange.Net.RateLimiting.RateLimitItemType,CryptoExchange.Net.Objects.RequestDefinition,System.String,System.Security.SecureString)">
            <inheritdoc />
        </member>
        <member name="T:CryptoExchange.Net.RateLimiting.Guards.RateLimitGuard">
            <inheritdoc />
        </member>
        <member name="P:CryptoExchange.Net.RateLimiting.Guards.RateLimitGuard.PerHost">
            <summary>
            Apply guard per host
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.RateLimiting.Guards.RateLimitGuard.PerEndpoint">
            <summary>
            Apply guard per endpoint
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.RateLimiting.Guards.RateLimitGuard.PerApiKey">
            <summary>
            Apply guard per API key
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.RateLimiting.Guards.RateLimitGuard.PerApiKeyPerEndpoint">
            <summary>
            Apply guard per API key per endpoint
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.RateLimiting.Guards.RateLimitGuard.Name">
            <inheritdoc />
        </member>
        <member name="P:CryptoExchange.Net.RateLimiting.Guards.RateLimitGuard.Description">
            <inheritdoc />
        </member>
        <member name="P:CryptoExchange.Net.RateLimiting.Guards.RateLimitGuard.Limit">
            <summary>
            The limit per period
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.RateLimiting.Guards.RateLimitGuard.TimeSpan">
            <summary>
            The time period for the limit
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.RateLimiting.Guards.RateLimitGuard.#ctor(System.Func{CryptoExchange.Net.Objects.RequestDefinition,System.String,System.Security.SecureString,System.String},CryptoExchange.Net.RateLimiting.Interfaces.IGuardFilter,System.Int32,System.TimeSpan,CryptoExchange.Net.Objects.RateLimitWindowType,System.Nullable{System.Double},System.Nullable{System.Int32})">
            <summary>
            ctor
            </summary>
            <param name="keySelector">The rate limit key selector</param>
            <param name="filter">Filter for rate limit items. Only when the rate limit item passes the filter the guard will apply</param>
            <param name="limit">Limit per period</param>
            <param name="timeSpan">Timespan for the period</param>
            <param name="windowType">Type of rate limit window</param>
            <param name="decayPerTimeSpan">The decay per timespan if windowType is DecayWindowTracker</param>
            <param name="connectionWeight">The weight of a new connection</param>
        </member>
        <member name="M:CryptoExchange.Net.RateLimiting.Guards.RateLimitGuard.#ctor(System.Func{CryptoExchange.Net.Objects.RequestDefinition,System.String,System.Security.SecureString,System.String},System.Collections.Generic.IEnumerable{CryptoExchange.Net.RateLimiting.Interfaces.IGuardFilter},System.Int32,System.TimeSpan,CryptoExchange.Net.Objects.RateLimitWindowType,System.Nullable{System.Double},System.Nullable{System.Int32})">
            <summary>
            ctor
            </summary>
            <param name="keySelector">The rate limit key selector</param>
            <param name="filters">Filters for rate limit items. Only when the rate limit item passes all filters the guard will apply</param>
            <param name="limit">Limit per period</param>
            <param name="timeSpan">Timespan for the period</param>
            <param name="windowType">Type of rate limit window</param>
            <param name="decayPerTimeSpan">The decay per timespan if windowType is DecayWindowTracker</param>
            <param name="connectionWeight">The weight of a new connection</param>
        </member>
        <member name="M:CryptoExchange.Net.RateLimiting.Guards.RateLimitGuard.Check(CryptoExchange.Net.RateLimiting.RateLimitItemType,CryptoExchange.Net.Objects.RequestDefinition,System.String,System.Security.SecureString,System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:CryptoExchange.Net.RateLimiting.Guards.RateLimitGuard.ApplyWeight(CryptoExchange.Net.RateLimiting.RateLimitItemType,CryptoExchange.Net.Objects.RequestDefinition,System.String,System.Security.SecureString,System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:CryptoExchange.Net.RateLimiting.Guards.RateLimitGuard.CreateTracker">
            <summary>
            Create a new WindowTracker
            </summary>
            <returns></returns>
        </member>
        <member name="T:CryptoExchange.Net.RateLimiting.Guards.RetryAfterGuard">
            <summary>
            Retry after guard
            </summary>
        </member>
        <member name="F:CryptoExchange.Net.RateLimiting.Guards.RetryAfterGuard._windowBuffer">
            <summary>
            Additional wait time to apply to account for time offset between server and client
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.RateLimiting.Guards.RetryAfterGuard.Name">
            <inheritdoc />
        </member>
        <member name="P:CryptoExchange.Net.RateLimiting.Guards.RetryAfterGuard.Description">
            <inheritdoc />
        </member>
        <member name="P:CryptoExchange.Net.RateLimiting.Guards.RetryAfterGuard.After">
            <summary>
            The timestamp after which requests are allowed again
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.RateLimiting.Guards.RetryAfterGuard.#ctor(System.DateTime)">
            <summary>
            ctor
            </summary>
            <param name="after"></param>
        </member>
        <member name="M:CryptoExchange.Net.RateLimiting.Guards.RetryAfterGuard.Check(CryptoExchange.Net.RateLimiting.RateLimitItemType,CryptoExchange.Net.Objects.RequestDefinition,System.String,System.Security.SecureString,System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:CryptoExchange.Net.RateLimiting.Guards.RetryAfterGuard.ApplyWeight(CryptoExchange.Net.RateLimiting.RateLimitItemType,CryptoExchange.Net.Objects.RequestDefinition,System.String,System.Security.SecureString,System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:CryptoExchange.Net.RateLimiting.Guards.RetryAfterGuard.UpdateAfter(System.DateTime)">
            <summary>
            Update the 'after' time
            </summary>
            <param name="after"></param>
        </member>
        <member name="T:CryptoExchange.Net.RateLimiting.Guards.SingleLimitGuard">
            <summary>
            Rate limit guard for a per endpoint limit
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.RateLimiting.Guards.SingleLimitGuard.Name">
            <inheritdoc />
        </member>
        <member name="P:CryptoExchange.Net.RateLimiting.Guards.SingleLimitGuard.Description">
            <inheritdoc />
        </member>
        <member name="M:CryptoExchange.Net.RateLimiting.Guards.SingleLimitGuard.#ctor(CryptoExchange.Net.Objects.RateLimitWindowType,System.Nullable{System.Double})">
            <summary>
            ctor
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.RateLimiting.Guards.SingleLimitGuard.Check(CryptoExchange.Net.RateLimiting.RateLimitItemType,CryptoExchange.Net.Objects.RequestDefinition,System.String,System.Security.SecureString,System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:CryptoExchange.Net.RateLimiting.Guards.SingleLimitGuard.ApplyWeight(CryptoExchange.Net.RateLimiting.RateLimitItemType,CryptoExchange.Net.Objects.RequestDefinition,System.String,System.Security.SecureString,System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:CryptoExchange.Net.RateLimiting.Guards.SingleLimitGuard.CreateTracker(System.Int32,System.TimeSpan)">
            <summary>
            Create a new WindowTracker
            </summary>
            <returns></returns>
        </member>
        <member name="T:CryptoExchange.Net.RateLimiting.Interfaces.IGuardFilter">
            <summary>
            Filter requests based on specific condition
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.RateLimiting.Interfaces.IGuardFilter.Passes(CryptoExchange.Net.RateLimiting.RateLimitItemType,CryptoExchange.Net.Objects.RequestDefinition,System.String,System.Security.SecureString)">
            <summary>
            Whether a request or connection passes this filter
            </summary>
            <param name="type">The type of item</param>
            <param name="definition">The request definition</param>
            <param name="host">The host address</param>
            <param name="apiKey">The API key</param>
            <returns>True if passed</returns>
        </member>
        <member name="T:CryptoExchange.Net.RateLimiting.Interfaces.IRateLimitGate">
            <summary>
            Rate limit gate
            </summary>
        </member>
        <member name="E:CryptoExchange.Net.RateLimiting.Interfaces.IRateLimitGate.RateLimitTriggered">
            <summary>
            Event when the rate limit is triggered
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.RateLimiting.Interfaces.IRateLimitGate.AddGuard(CryptoExchange.Net.RateLimiting.Interfaces.IRateLimitGuard)">
            <summary>
            Add a rate limit guard
            </summary>
            <param name="guard">Guard to add</param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.RateLimiting.Interfaces.IRateLimitGate.SetRetryAfterGuardAsync(System.DateTime)">
            <summary>
            Set a RetryAfter guard, can be used when a server rate limit is hit and a RetryAfter header is specified
            </summary>
            <param name="retryAfter">The time after which requests can be send again</param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.RateLimiting.Interfaces.IRateLimitGate.SetSingleLimitGuard(CryptoExchange.Net.RateLimiting.Guards.SingleLimitGuard)">
            <summary>
            Set the SingleLimitGuard for handling individual endpoint rate limits
            </summary>
            <param name="guard"></param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.RateLimiting.Interfaces.IRateLimitGate.GetRetryAfterTime">
            <summary>
            Returns the 'retry after' timestamp if set
            </summary>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.RateLimiting.Interfaces.IRateLimitGate.ProcessAsync(Microsoft.Extensions.Logging.ILogger,System.Int32,CryptoExchange.Net.RateLimiting.RateLimitItemType,CryptoExchange.Net.Objects.RequestDefinition,System.String,System.Security.SecureString,System.Int32,CryptoExchange.Net.Objects.RateLimitingBehaviour,System.Threading.CancellationToken)">
            <summary>
            Process a request. Enforces the configured rate limits. When a rate limit is hit will wait for the rate limit to pass if RateLimitingBehaviour is Wait, or return an error if it is set to Fail
            </summary>
            <param name="logger">Logger</param>
            <param name="itemId">Id of the item to check</param>
            <param name="type">The rate limit item type</param>
            <param name="definition">The request definition</param>
            <param name="baseAddress">The host address</param>
            <param name="apiKey">The API key</param>
            <param name="requestWeight">Request weight</param>
            <param name="behaviour">Behaviour when rate limit is hit</param>
            <param name="ct">Cancelation token</param>
            <returns>Error if RateLimitingBehaviour is Fail and rate limit is hit</returns>
        </member>
        <member name="M:CryptoExchange.Net.RateLimiting.Interfaces.IRateLimitGate.ProcessSingleAsync(Microsoft.Extensions.Logging.ILogger,System.Int32,CryptoExchange.Net.RateLimiting.RateLimitItemType,CryptoExchange.Net.Objects.RequestDefinition,System.String,System.Security.SecureString,System.Int32,CryptoExchange.Net.Objects.RateLimitingBehaviour,System.Threading.CancellationToken)">
            <summary>
            Enforces the rate limit as defined in the request definition. When a rate limit is hit will wait for the rate limit to pass if RateLimitingBehaviour is Wait, or return an error if it is set to Fail
            </summary>
            <param name="logger">Logger</param>
            <param name="itemId">Id of the item to check</param>
            <param name="type">The rate limit item type</param>
            <param name="definition">The request definition</param>
            <param name="baseAddress">The host address</param>
            <param name="apiKey">The API key</param>
            <param name="requestWeight">Request weight</param>
            <param name="behaviour">Behaviour when rate limit is hit</param>
            <param name="ct">Cancelation token</param>
            <returns>Error if RateLimitingBehaviour is Fail and rate limit is hit</returns>
        </member>
        <member name="T:CryptoExchange.Net.RateLimiting.Interfaces.IRateLimitGuard">
            <summary>
            Rate limit guard
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.RateLimiting.Interfaces.IRateLimitGuard.Name">
            <summary>
            Name
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.RateLimiting.Interfaces.IRateLimitGuard.Description">
            <summary>
            Description
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.RateLimiting.Interfaces.IRateLimitGuard.Check(CryptoExchange.Net.RateLimiting.RateLimitItemType,CryptoExchange.Net.Objects.RequestDefinition,System.String,System.Security.SecureString,System.Int32)">
            <summary>
            Check whether a request can pass this rate limit guard
            </summary>
            <param name="type">The rate limit item type</param>
            <param name="definition">The request definition</param>
            <param name="host">The host address</param>
            <param name="apiKey">The API key</param>
            <param name="requestWeight">The request weight</param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.RateLimiting.Interfaces.IRateLimitGuard.ApplyWeight(CryptoExchange.Net.RateLimiting.RateLimitItemType,CryptoExchange.Net.Objects.RequestDefinition,System.String,System.Security.SecureString,System.Int32)">
            <summary>
            Apply the request to this guard with the specified weight
            </summary>
            <param name="type">The rate limit item type</param>
            <param name="definition">The request definition</param>
            <param name="host">The host address</param>
            <param name="apiKey">The API key</param>
            <param name="requestWeight">The request weight</param>
            <returns></returns>
        </member>
        <member name="T:CryptoExchange.Net.RateLimiting.Interfaces.IWindowTracker">
            <summary>
            Rate limit window tracker
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.RateLimiting.Interfaces.IWindowTracker.TimePeriod">
            <summary>
            Time period the limit is for
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.RateLimiting.Interfaces.IWindowTracker.Limit">
            <summary>
            The limit in the time period
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.RateLimiting.Interfaces.IWindowTracker.Current">
            <summary>
            The current count within the time period
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.RateLimiting.Interfaces.IWindowTracker.GetWaitTime(System.Int32)">
            <summary>
            Get the time to wait to fit the weight
            </summary>
            <param name="weight"></param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.RateLimiting.Interfaces.IWindowTracker.ApplyWeight(System.Int32)">
            <summary>
            Register the weight in this window
            </summary>
            <param name="weight">Request weight</param>
        </member>
        <member name="T:CryptoExchange.Net.RateLimiting.LimitCheck">
            <summary>
            Limit check
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.RateLimiting.LimitCheck.Applicable">
            <summary>
            Is guard applicable
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.RateLimiting.LimitCheck.Delay">
            <summary>
            Delay needed
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.RateLimiting.LimitCheck.Current">
            <summary>
            Current counter
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.RateLimiting.LimitCheck.Limit">
            <summary>
            Limit
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.RateLimiting.LimitCheck.Period">
            <summary>
            Time period
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.RateLimiting.LimitCheck.NotApplicable">
            <summary>
            Not applicable
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.RateLimiting.LimitCheck.NotNeeded">
            <summary>
            No wait needed
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.RateLimiting.LimitCheck.Needed(System.TimeSpan,System.Int32,System.TimeSpan,System.Int32)">
            <summary>
            Wait needed
            </summary>
            <param name="delay">The delay needed</param>
            <param name="limit">Limit per period</param>
            <param name="period">Period the limit is for</param>
            <param name="current">Current counter</param>
            <returns></returns>
        </member>
        <member name="T:CryptoExchange.Net.RateLimiting.LimitEntry">
            <summary>
            A rate limit entry
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.RateLimiting.LimitEntry.Timestamp">
            <summary>
            Timestamp of the item
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.RateLimiting.LimitEntry.Weight">
            <summary>
            Item weight
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.RateLimiting.LimitEntry.#ctor(System.DateTime,System.Int32)">
            <summary>
            ctor
            </summary>
            <param name="timestamp"></param>
            <param name="weight"></param>
        </member>
        <member name="T:CryptoExchange.Net.RateLimiting.RateLimitEvent">
            <summary>
            Rate limit event
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.RateLimiting.RateLimitEvent.ApiLimit">
            <summary>
            Name of the API limit that is reached
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.RateLimiting.RateLimitEvent.LimitDescription">
            <summary>
            Description of the limit that is reached
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.RateLimiting.RateLimitEvent.RequestDefinition">
            <summary>
            The request definition
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.RateLimiting.RateLimitEvent.Host">
            <summary>
            The host the request is for
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.RateLimiting.RateLimitEvent.Current">
            <summary>
            The current counter value
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.RateLimiting.RateLimitEvent.RequestWeight">
            <summary>
            The weight of the limited request
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.RateLimiting.RateLimitEvent.Limit">
            <summary>
            The limit per time period
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.RateLimiting.RateLimitEvent.TimePeriod">
            <summary>
            The time period the limit is for
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.RateLimiting.RateLimitEvent.DelayTime">
            <summary>
            The time the request will be delayed for if the Behaviour is RateLimitingBehaviour.Wait
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.RateLimiting.RateLimitEvent.Behaviour">
            <summary>
            The handling behaviour for the rquest 
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.RateLimiting.RateLimitEvent.#ctor(System.String,System.String,CryptoExchange.Net.Objects.RequestDefinition,System.String,System.Int32,System.Int32,System.Nullable{System.Int32},System.Nullable{System.TimeSpan},System.Nullable{System.TimeSpan},CryptoExchange.Net.Objects.RateLimitingBehaviour)">
            <summary>
            ctor
            </summary>
            <param name="apiLimit"></param>
            <param name="limitDescription"></param>
            <param name="definition"></param>
            <param name="host"></param>
            <param name="current"></param>
            <param name="requestWeight"></param>
            <param name="limit"></param>
            <param name="timePeriod"></param>
            <param name="delayTime"></param>
            <param name="behaviour"></param>
        </member>
        <member name="T:CryptoExchange.Net.RateLimiting.RateLimitGate">
            <inheritdoc />
        </member>
        <member name="E:CryptoExchange.Net.RateLimiting.RateLimitGate.RateLimitTriggered">
            <inheritdoc />
        </member>
        <member name="M:CryptoExchange.Net.RateLimiting.RateLimitGate.#ctor(System.String)">
            <summary>
            ctor
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.RateLimiting.RateLimitGate.ProcessAsync(Microsoft.Extensions.Logging.ILogger,System.Int32,CryptoExchange.Net.RateLimiting.RateLimitItemType,CryptoExchange.Net.Objects.RequestDefinition,System.String,System.Security.SecureString,System.Int32,CryptoExchange.Net.Objects.RateLimitingBehaviour,System.Threading.CancellationToken)">
            <inheritdoc />
        </member>
        <member name="M:CryptoExchange.Net.RateLimiting.RateLimitGate.ProcessSingleAsync(Microsoft.Extensions.Logging.ILogger,System.Int32,CryptoExchange.Net.RateLimiting.RateLimitItemType,CryptoExchange.Net.Objects.RequestDefinition,System.String,System.Security.SecureString,System.Int32,CryptoExchange.Net.Objects.RateLimitingBehaviour,System.Threading.CancellationToken)">
            <inheritdoc />
        </member>
        <member name="M:CryptoExchange.Net.RateLimiting.RateLimitGate.AddGuard(CryptoExchange.Net.RateLimiting.Interfaces.IRateLimitGuard)">
            <inheritdoc />
        </member>
        <member name="M:CryptoExchange.Net.RateLimiting.RateLimitGate.SetSingleLimitGuard(CryptoExchange.Net.RateLimiting.Guards.SingleLimitGuard)">
            <inheritdoc />
        </member>
        <member name="M:CryptoExchange.Net.RateLimiting.RateLimitGate.SetRetryAfterGuardAsync(System.DateTime)">
            <inheritdoc />
        </member>
        <member name="M:CryptoExchange.Net.RateLimiting.RateLimitGate.GetRetryAfterTime">
            <inheritdoc />
        </member>
        <member name="T:CryptoExchange.Net.RateLimiting.RateLimitItemType">
            <summary>
            Rate limit item type
            </summary>
        </member>
        <member name="F:CryptoExchange.Net.RateLimiting.RateLimitItemType.Connection">
            <summary>
            A connection attempt
            </summary>
        </member>
        <member name="F:CryptoExchange.Net.RateLimiting.RateLimitItemType.Request">
            <summary>
            A request
            </summary>
        </member>
        <member name="T:CryptoExchange.Net.RateLimiting.RateLimitState">
            <summary>
            Limit state
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.RateLimiting.RateLimitState.Limit">
            <summary>
            Limit
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.RateLimiting.RateLimitState.Period">
            <summary>
            Period 
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.RateLimiting.RateLimitState.Current">
            <summary>
            Current count
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.RateLimiting.RateLimitState.IsApplied">
            <summary>
            Whether the limit is applied
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.RateLimiting.RateLimitState.#ctor(System.Boolean,System.Int32,System.TimeSpan,System.Int32)">
            <summary>
            ctor
            </summary>
            <param name="applied"></param>
            <param name="limit"></param>
            <param name="period"></param>
            <param name="current"></param>
        </member>
        <member name="P:CryptoExchange.Net.RateLimiting.RateLimitState.NotApplied">
            <summary>
            Not applied result
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.RateLimiting.RateLimitState.Applied(System.Int32,System.TimeSpan,System.Int32)">
            <summary>
            Applied result
            </summary>
            <param name="limit"></param>
            <param name="period"></param>
            <param name="current"></param>
            <returns></returns>
        </member>
        <member name="P:CryptoExchange.Net.RateLimiting.Trackers.DecayWindowTracker.TimePeriod">
            <inheritdoc />
        </member>
        <member name="P:CryptoExchange.Net.RateLimiting.Trackers.DecayWindowTracker.DecreaseRate">
            <summary>
            Decrease rate per TimePeriod
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.RateLimiting.Trackers.DecayWindowTracker.Limit">
            <inheritdoc />
        </member>
        <member name="P:CryptoExchange.Net.RateLimiting.Trackers.DecayWindowTracker.Current">
            <inheritdoc />
        </member>
        <member name="M:CryptoExchange.Net.RateLimiting.Trackers.DecayWindowTracker.GetWaitTime(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:CryptoExchange.Net.RateLimiting.Trackers.DecayWindowTracker.ApplyWeight(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:CryptoExchange.Net.RateLimiting.Trackers.DecayWindowTracker.DecreaseCounter(System.DateTime)">
            <summary>
            Decrease the counter based on time passed since last update and the decay rate
            </summary>
            <param name="time"></param>
        </member>
        <member name="M:CryptoExchange.Net.RateLimiting.Trackers.DecayWindowTracker.DetermineWaitTime(System.Int32)">
            <summary>
            Determine the time to wait before the weight would fit
            </summary>
            <param name="requestWeight"></param>
            <returns></returns>
        </member>
        <member name="P:CryptoExchange.Net.RateLimiting.Trackers.FixedAfterStartWindowTracker.TimePeriod">
            <inheritdoc />
        </member>
        <member name="P:CryptoExchange.Net.RateLimiting.Trackers.FixedAfterStartWindowTracker.Limit">
            <inheritdoc />
        </member>
        <member name="P:CryptoExchange.Net.RateLimiting.Trackers.FixedAfterStartWindowTracker.Current">
            <inheritdoc />
        </member>
        <member name="F:CryptoExchange.Net.RateLimiting.Trackers.FixedAfterStartWindowTracker._fixedWindowBuffer">
            <summary>
            Additional wait time to apply to account for time offset between server and client
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.RateLimiting.Trackers.FixedAfterStartWindowTracker.ApplyWeight(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:CryptoExchange.Net.RateLimiting.Trackers.FixedAfterStartWindowTracker.RemoveBefore(System.DateTime)">
            <summary>
            Remove items before a certain time
            </summary>
            <param name="time"></param>
        </member>
        <member name="M:CryptoExchange.Net.RateLimiting.Trackers.FixedAfterStartWindowTracker.DetermineWaitTime">
            <summary>
            Determine the time to wait before a new item would fit
            </summary>
            <returns></returns>
        </member>
        <member name="P:CryptoExchange.Net.RateLimiting.Trackers.FixedWindowTracker.TimePeriod">
            <inheritdoc />
        </member>
        <member name="P:CryptoExchange.Net.RateLimiting.Trackers.FixedWindowTracker.Limit">
            <inheritdoc />
        </member>
        <member name="P:CryptoExchange.Net.RateLimiting.Trackers.FixedWindowTracker.Current">
            <inheritdoc />
        </member>
        <member name="F:CryptoExchange.Net.RateLimiting.Trackers.FixedWindowTracker._fixedWindowBuffer">
            <summary>
            Additional wait time to apply to account for time offset between server and client
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.RateLimiting.Trackers.FixedWindowTracker.GetWaitTime(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:CryptoExchange.Net.RateLimiting.Trackers.FixedWindowTracker.ApplyWeight(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:CryptoExchange.Net.RateLimiting.Trackers.FixedWindowTracker.RemoveBefore(System.DateTime)">
            <summary>
            Remove items before a certain time
            </summary>
            <param name="time"></param>
        </member>
        <member name="M:CryptoExchange.Net.RateLimiting.Trackers.FixedWindowTracker.DetermineWaitTime">
            <summary>
            Determine the time to wait before a new item would fit
            </summary>
            <returns></returns>
        </member>
        <member name="P:CryptoExchange.Net.RateLimiting.Trackers.SlidingWindowTracker.TimePeriod">
            <inheritdoc />
        </member>
        <member name="P:CryptoExchange.Net.RateLimiting.Trackers.SlidingWindowTracker.Limit">
            <inheritdoc />
        </member>
        <member name="P:CryptoExchange.Net.RateLimiting.Trackers.SlidingWindowTracker.Current">
            <inheritdoc />
        </member>
        <member name="M:CryptoExchange.Net.RateLimiting.Trackers.SlidingWindowTracker.GetWaitTime(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:CryptoExchange.Net.RateLimiting.Trackers.SlidingWindowTracker.ApplyWeight(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:CryptoExchange.Net.RateLimiting.Trackers.SlidingWindowTracker.RemoveBefore(System.DateTime)">
            <summary>
            Remove items before a certain time
            </summary>
            <param name="time"></param>
        </member>
        <member name="M:CryptoExchange.Net.RateLimiting.Trackers.SlidingWindowTracker.DetermineWaitTime(System.Int32)">
            <summary>
            Determine the time to wait before the weight would fit
            </summary>
            <returns></returns>
        </member>
        <member name="T:CryptoExchange.Net.Requests.Request">
            <summary>
            Request object, wrapper for HttpRequestMessage
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.Requests.Request.#ctor(System.Net.Http.HttpRequestMessage,System.Net.Http.HttpClient,System.Int32)">
            <summary>
            Create request object for web request
            </summary>
            <param name="request"></param>
            <param name="client"></param>        
            <param name="requestId"></param>        
        </member>
        <member name="P:CryptoExchange.Net.Requests.Request.Content">
            <inheritdoc />
        </member>
        <member name="P:CryptoExchange.Net.Requests.Request.Accept">
            <inheritdoc />
        </member>
        <member name="P:CryptoExchange.Net.Requests.Request.Method">
            <inheritdoc />
        </member>
        <member name="P:CryptoExchange.Net.Requests.Request.Uri">
            <inheritdoc />
        </member>
        <member name="P:CryptoExchange.Net.Requests.Request.RequestId">
            <inheritdoc />
        </member>
        <member name="M:CryptoExchange.Net.Requests.Request.SetContent(System.String,System.String)">
            <inheritdoc />
        </member>
        <member name="M:CryptoExchange.Net.Requests.Request.AddHeader(System.String,System.String)">
            <inheritdoc />
        </member>
        <member name="M:CryptoExchange.Net.Requests.Request.GetHeaders">
            <inheritdoc />
        </member>
        <member name="M:CryptoExchange.Net.Requests.Request.SetContent(System.Byte[])">
            <inheritdoc />
        </member>
        <member name="M:CryptoExchange.Net.Requests.Request.GetResponseAsync(System.Threading.CancellationToken)">
            <inheritdoc />
        </member>
        <member name="T:CryptoExchange.Net.Requests.RequestFactory">
            <summary>
            Request factory
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.Requests.RequestFactory.Configure(CryptoExchange.Net.Objects.ApiProxy,System.TimeSpan,System.Net.Http.HttpClient)">
            <inheritdoc />
        </member>
        <member name="M:CryptoExchange.Net.Requests.RequestFactory.Create(System.Net.Http.HttpMethod,System.Uri,System.Int32)">
            <inheritdoc />
        </member>
        <member name="T:CryptoExchange.Net.Requests.Response">
            <summary>
            Response object, wrapper for HttpResponseMessage
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Requests.Response.StatusCode">
            <inheritdoc />
        </member>
        <member name="P:CryptoExchange.Net.Requests.Response.IsSuccessStatusCode">
            <inheritdoc />
        </member>
        <member name="P:CryptoExchange.Net.Requests.Response.ContentLength">
            <inheritdoc />
        </member>
        <member name="P:CryptoExchange.Net.Requests.Response.ResponseHeaders">
            <inheritdoc />
        </member>
        <member name="M:CryptoExchange.Net.Requests.Response.#ctor(System.Net.Http.HttpResponseMessage)">
            <summary>
            Create response for a http response message
            </summary>
            <param name="response">The actual response</param>
        </member>
        <member name="M:CryptoExchange.Net.Requests.Response.GetResponseStreamAsync">
            <inheritdoc />
        </member>
        <member name="M:CryptoExchange.Net.Requests.Response.Close">
            <inheritdoc />
        </member>
        <member name="T:CryptoExchange.Net.Sockets.CryptoExchangeWebSocketClient">
            <summary>
            A wrapper around the ClientWebSocket
            </summary>
        </member>
        <member name="F:CryptoExchange.Net.Sockets.CryptoExchangeWebSocketClient._receivedMessages">
            <summary>
            Received messages, the size and the timstamp
            </summary>
        </member>
        <member name="F:CryptoExchange.Net.Sockets.CryptoExchangeWebSocketClient._receivedMessagesLock">
            <summary>
            Received messages lock
            </summary>
        </member>
        <member name="F:CryptoExchange.Net.Sockets.CryptoExchangeWebSocketClient._logger">
            <summary>
            Log
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Sockets.CryptoExchangeWebSocketClient.Id">
            <inheritdoc />
        </member>
        <member name="P:CryptoExchange.Net.Sockets.CryptoExchangeWebSocketClient.Parameters">
            <inheritdoc />
        </member>
        <member name="P:CryptoExchange.Net.Sockets.CryptoExchangeWebSocketClient.LastActionTime">
            <summary>
            The timestamp this socket has been active for the last time
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Sockets.CryptoExchangeWebSocketClient.Uri">
            <inheritdoc />
        </member>
        <member name="P:CryptoExchange.Net.Sockets.CryptoExchangeWebSocketClient.IsClosed">
            <inheritdoc />
        </member>
        <member name="P:CryptoExchange.Net.Sockets.CryptoExchangeWebSocketClient.IsOpen">
            <inheritdoc />
        </member>
        <member name="P:CryptoExchange.Net.Sockets.CryptoExchangeWebSocketClient.IncomingKbps">
            <inheritdoc />
        </member>
        <member name="E:CryptoExchange.Net.Sockets.CryptoExchangeWebSocketClient.OnClose">
            <inheritdoc />
        </member>
        <member name="E:CryptoExchange.Net.Sockets.CryptoExchangeWebSocketClient.OnStreamMessage">
            <inheritdoc />
        </member>
        <member name="E:CryptoExchange.Net.Sockets.CryptoExchangeWebSocketClient.OnRequestSent">
            <inheritdoc />
        </member>
        <member name="E:CryptoExchange.Net.Sockets.CryptoExchangeWebSocketClient.OnRequestRateLimited">
            <inheritdoc />
        </member>
        <member name="E:CryptoExchange.Net.Sockets.CryptoExchangeWebSocketClient.OnError">
            <inheritdoc />
        </member>
        <member name="E:CryptoExchange.Net.Sockets.CryptoExchangeWebSocketClient.OnOpen">
            <inheritdoc />
        </member>
        <member name="E:CryptoExchange.Net.Sockets.CryptoExchangeWebSocketClient.OnReconnecting">
            <inheritdoc />
        </member>
        <member name="E:CryptoExchange.Net.Sockets.CryptoExchangeWebSocketClient.OnReconnected">
            <inheritdoc />
        </member>
        <member name="P:CryptoExchange.Net.Sockets.CryptoExchangeWebSocketClient.GetReconnectionUrl">
            <inheritdoc />
        </member>
        <member name="M:CryptoExchange.Net.Sockets.CryptoExchangeWebSocketClient.#ctor(Microsoft.Extensions.Logging.ILogger,CryptoExchange.Net.Objects.Sockets.WebSocketParameters)">
            <summary>
            ctor
            </summary>
            <param name="logger">The log object to use</param>
            <param name="websocketParameters">The parameters for this socket</param>
        </member>
        <member name="M:CryptoExchange.Net.Sockets.CryptoExchangeWebSocketClient.ConnectAsync">
            <inheritdoc />
        </member>
        <member name="M:CryptoExchange.Net.Sockets.CryptoExchangeWebSocketClient.CreateSocket">
            <summary>
            Create the socket object
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.Sockets.CryptoExchangeWebSocketClient.ProcessAsync">
            <inheritdoc />
        </member>
        <member name="M:CryptoExchange.Net.Sockets.CryptoExchangeWebSocketClient.Send(System.Int32,System.String,System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:CryptoExchange.Net.Sockets.CryptoExchangeWebSocketClient.ReconnectAsync">
            <inheritdoc />
        </member>
        <member name="M:CryptoExchange.Net.Sockets.CryptoExchangeWebSocketClient.CloseAsync">
            <inheritdoc />
        </member>
        <member name="M:CryptoExchange.Net.Sockets.CryptoExchangeWebSocketClient.CloseInternalAsync">
            <summary>
            Internal close method
            </summary>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Sockets.CryptoExchangeWebSocketClient.Dispose">
            <summary>
            Dispose the socket
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.Sockets.CryptoExchangeWebSocketClient.SendLoopAsync">
            <summary>
            Loop for sending data
            </summary>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Sockets.CryptoExchangeWebSocketClient.ReceiveLoopAsync">
            <summary>
            Loop for receiving and reassembling data
            </summary>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Sockets.CryptoExchangeWebSocketClient.ProcessData(System.Net.WebSockets.WebSocketMessageType,System.ReadOnlyMemory{System.Byte})">
            <summary>
            Proccess a stream message
            </summary>
            <param name="type"></param>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Sockets.CryptoExchangeWebSocketClient.CheckTimeoutAsync">
            <summary>
            Checks if there is no data received for a period longer than the specified timeout
            </summary>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Sockets.CryptoExchangeWebSocketClient.NextStreamId">
            <summary>
            Get the next identifier
            </summary>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Sockets.CryptoExchangeWebSocketClient.UpdateReceivedMessages">
            <summary>
            Update the received messages list, removing messages received longer than 3s ago
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.Sockets.CryptoExchangeWebSocketClient.SetProxy(System.Net.WebSockets.ClientWebSocket,CryptoExchange.Net.Objects.ApiProxy)">
            <summary>
            Set proxy on socket
            </summary>
            <param name="socket"></param>
            <param name="proxy"></param>
            <exception cref="T:System.ArgumentException"></exception>
        </member>
        <member name="T:CryptoExchange.Net.Sockets.SendItem">
            <summary>
            Message info
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Sockets.SendItem.Id">
            <summary>
            The request id
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Sockets.SendItem.Weight">
            <summary>
            The request weight
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Sockets.SendItem.SendTime">
            <summary>
            Timestamp the request was sent
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Sockets.SendItem.Bytes">
            <summary>
            The bytes to send
            </summary>
        </member>
        <member name="T:CryptoExchange.Net.Sockets.ReceiveItem">
            <summary>
            Received message info
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Sockets.ReceiveItem.Timestamp">
            <summary>
            Timestamp of the received data
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Sockets.ReceiveItem.Bytes">
            <summary>
            Number of bytes received
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.Sockets.ReceiveItem.#ctor(System.DateTime,System.Int32)">
            <summary>
            ctor
            </summary>
            <param name="timestamp"></param>
            <param name="bytes"></param>
        </member>
        <member name="T:CryptoExchange.Net.Sockets.PeriodicTaskRegistration">
            <summary>
            Periodic task registration
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Sockets.PeriodicTaskRegistration.Identifier">
            <summary>
            Identifier
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Sockets.PeriodicTaskRegistration.Interval">
            <summary>
            Interval of query
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Sockets.PeriodicTaskRegistration.QueryDelegate">
            <summary>
            Delegate for getting the query
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Sockets.PeriodicTaskRegistration.Callback">
            <summary>
            Callback after query
            </summary>
        </member>
        <member name="T:CryptoExchange.Net.Sockets.Query">
            <summary>
            Query 
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Sockets.Query.Id">
            <summary>
            Unique identifier
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Sockets.Query.CanHandleData">
            <summary>
            Can handle data
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Sockets.Query.Completed">
            <summary>
            Has this query been completed
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Sockets.Query.RequestTimestamp">
            <summary>
            Timestamp of when the request was send
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Sockets.Query.Result">
            <summary>
            Result
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Sockets.Query.Response">
            <summary>
            Response
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Sockets.Query.ContinueAwaiter">
            <summary>
            Wait event for the calling message processing thread
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Sockets.Query.ListenerIdentifiers">
            <summary>
            Strings to match this query to a received message
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Sockets.Query.Request">
            <summary>
            The query request object
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Sockets.Query.Authenticated">
            <summary>
            If this is a private request
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Sockets.Query.Weight">
            <summary>
            Weight of the query
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.Sockets.Query.GetMessageType(CryptoExchange.Net.Interfaces.IMessageAccessor)">
            <summary>
            Get the type the message should be deserialized to
            </summary>
            <param name="message"></param>
            <returns></returns>
        </member>
        <member name="F:CryptoExchange.Net.Sockets.Query._event">
            <summary>
            Wait event for response
            </summary>
        </member>
        <member name="F:CryptoExchange.Net.Sockets.Query._cts">
            <summary>
            Cancellation token
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.Sockets.Query.#ctor(System.Object,System.Boolean,System.Int32)">
            <summary>
            ctor
            </summary>
            <param name="request"></param>
            <param name="authenticated"></param>
            <param name="weight"></param>
        </member>
        <member name="M:CryptoExchange.Net.Sockets.Query.IsSend(System.TimeSpan)">
            <summary>
            Signal that the request has been send and the timeout timer should start
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.Sockets.Query.WaitAsync(System.TimeSpan)">
            <summary>
            Wait untill timeout or the request is competed
            </summary>
            <param name="timeout"></param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Sockets.Query.Deserialize(CryptoExchange.Net.Interfaces.IMessageAccessor,System.Type)">
            <inheritdoc />
        </member>
        <member name="M:CryptoExchange.Net.Sockets.Query.Timeout">
            <summary>
            Mark request as timeout
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.Sockets.Query.Fail(CryptoExchange.Net.Objects.Error)">
            <summary>
            Mark request as failed
            </summary>
            <param name="error"></param>
        </member>
        <member name="M:CryptoExchange.Net.Sockets.Query.Handle(CryptoExchange.Net.Sockets.SocketConnection,CryptoExchange.Net.Objects.Sockets.DataEvent{System.Object})">
            <summary>
            Handle a response message
            </summary>
            <param name="message"></param>
            <param name="connection"></param>
            <returns></returns>
        </member>
        <member name="T:CryptoExchange.Net.Sockets.Query`1">
            <summary>
            Query
            </summary>
            <typeparam name="TResponse">Response object type</typeparam>
        </member>
        <member name="M:CryptoExchange.Net.Sockets.Query`1.GetMessageType(CryptoExchange.Net.Interfaces.IMessageAccessor)">
            <inheritdoc />
        </member>
        <member name="P:CryptoExchange.Net.Sockets.Query`1.TypedResult">
            <summary>
            The typed call result
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.Sockets.Query`1.#ctor(System.Object,System.Boolean,System.Int32)">
            <summary>
            ctor
            </summary>
            <param name="request"></param>
            <param name="authenticated"></param>
            <param name="weight"></param>
        </member>
        <member name="M:CryptoExchange.Net.Sockets.Query`1.Handle(CryptoExchange.Net.Sockets.SocketConnection,CryptoExchange.Net.Objects.Sockets.DataEvent{System.Object})">
            <inheritdoc />
        </member>
        <member name="M:CryptoExchange.Net.Sockets.Query`1.HandleMessage(CryptoExchange.Net.Sockets.SocketConnection,CryptoExchange.Net.Objects.Sockets.DataEvent{`0})">
            <summary>
            Handle the query response
            </summary>
            <param name="connection"></param>
            <param name="message"></param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Sockets.Query`1.Timeout">
            <inheritdoc />
        </member>
        <member name="M:CryptoExchange.Net.Sockets.Query`1.Fail(CryptoExchange.Net.Objects.Error)">
            <inheritdoc />
        </member>
        <member name="T:CryptoExchange.Net.Sockets.SocketConnection">
            <summary>
            A single socket connection to the server
            </summary>
        </member>
        <member name="T:CryptoExchange.Net.Sockets.SocketConnection.SocketConnectionState">
            <summary>
            State of a the connection
            </summary>
            <param name="Id">The id of the socket connection</param>
            <param name="Address">The connection URI</param>
            <param name="Subscriptions">Number of subscriptions on this socket</param>
            <param name="Status">Socket status</param>
            <param name="Authenticated">If the connection is authenticated</param>
            <param name="DownloadSpeed">Download speed over this socket</param>
            <param name="PendingQueries">Number of non-completed queries</param>
            <param name="SubscriptionStates">State for each subscription on this socket</param>
        </member>
        <member name="M:CryptoExchange.Net.Sockets.SocketConnection.SocketConnectionState.#ctor(System.Int32,System.String,System.Int32,CryptoExchange.Net.Sockets.SocketConnection.SocketStatus,System.Boolean,System.Double,System.Int32,System.Collections.Generic.List{CryptoExchange.Net.Sockets.Subscription.SubscriptionState})">
            <summary>
            State of a the connection
            </summary>
            <param name="Id">The id of the socket connection</param>
            <param name="Address">The connection URI</param>
            <param name="Subscriptions">Number of subscriptions on this socket</param>
            <param name="Status">Socket status</param>
            <param name="Authenticated">If the connection is authenticated</param>
            <param name="DownloadSpeed">Download speed over this socket</param>
            <param name="PendingQueries">Number of non-completed queries</param>
            <param name="SubscriptionStates">State for each subscription on this socket</param>
        </member>
        <member name="P:CryptoExchange.Net.Sockets.SocketConnection.SocketConnectionState.Id">
            <summary>The id of the socket connection</summary>
        </member>
        <member name="P:CryptoExchange.Net.Sockets.SocketConnection.SocketConnectionState.Address">
            <summary>The connection URI</summary>
        </member>
        <member name="P:CryptoExchange.Net.Sockets.SocketConnection.SocketConnectionState.Subscriptions">
            <summary>Number of subscriptions on this socket</summary>
        </member>
        <member name="P:CryptoExchange.Net.Sockets.SocketConnection.SocketConnectionState.Status">
            <summary>Socket status</summary>
        </member>
        <member name="P:CryptoExchange.Net.Sockets.SocketConnection.SocketConnectionState.Authenticated">
            <summary>If the connection is authenticated</summary>
        </member>
        <member name="P:CryptoExchange.Net.Sockets.SocketConnection.SocketConnectionState.DownloadSpeed">
            <summary>Download speed over this socket</summary>
        </member>
        <member name="P:CryptoExchange.Net.Sockets.SocketConnection.SocketConnectionState.PendingQueries">
            <summary>Number of non-completed queries</summary>
        </member>
        <member name="P:CryptoExchange.Net.Sockets.SocketConnection.SocketConnectionState.SubscriptionStates">
            <summary>State for each subscription on this socket</summary>
        </member>
        <member name="E:CryptoExchange.Net.Sockets.SocketConnection.ConnectionLost">
            <summary>
            Connection lost event
            </summary>
        </member>
        <member name="E:CryptoExchange.Net.Sockets.SocketConnection.ConnectionClosed">
            <summary>
            Connection closed and no reconnect is happening
            </summary>
        </member>
        <member name="E:CryptoExchange.Net.Sockets.SocketConnection.ConnectionRestored">
            <summary>
            Connecting restored event
            </summary>
        </member>
        <member name="E:CryptoExchange.Net.Sockets.SocketConnection.ActivityPaused">
            <summary>
            The connection is paused event
            </summary>
        </member>
        <member name="E:CryptoExchange.Net.Sockets.SocketConnection.ActivityUnpaused">
            <summary>
            The connection is unpaused event
            </summary>
        </member>
        <member name="E:CryptoExchange.Net.Sockets.SocketConnection.UnhandledMessage">
            <summary>
            Unhandled message event
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Sockets.SocketConnection.UserSubscriptionCount">
            <summary>
            The amount of subscriptions on this connection
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Sockets.SocketConnection.Subscriptions">
            <summary>
            Get a copy of the current message subscriptions
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Sockets.SocketConnection.Authenticated">
            <summary>
            If the connection has been authenticated
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Sockets.SocketConnection.Connected">
            <summary>
            If connection is made
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Sockets.SocketConnection.SocketId">
            <summary>
            The unique ID of the socket
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Sockets.SocketConnection.IncomingKbps">
            <summary>
            The current kilobytes per second of data being received, averaged over the last 3 seconds
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Sockets.SocketConnection.ConnectionUri">
            <summary>
            The connection uri
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Sockets.SocketConnection.ApiClient">
            <summary>
            The API client the connection is for
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Sockets.SocketConnection.DisconnectTime">
            <summary>
            Time of disconnecting
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Sockets.SocketConnection.Tag">
            <summary>
            Tag for identificaion
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Sockets.SocketConnection.Properties">
            <summary>
            Additional properties for this connection
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Sockets.SocketConnection.PausedActivity">
            <summary>
            If activity is paused
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Sockets.SocketConnection.Status">
            <summary>
            Status of the socket connection
            </summary>
        </member>
        <member name="F:CryptoExchange.Net.Sockets.SocketConnection.periodicTask">
            <summary>
            The task that is sending periodic data on the websocket. Can be used for sending Ping messages every x seconds or similair. Not necesarry.
            </summary>
        </member>
        <member name="F:CryptoExchange.Net.Sockets.SocketConnection.periodicEvent">
            <summary>
            Wait event for the periodicTask
            </summary>
        </member>
        <member name="F:CryptoExchange.Net.Sockets.SocketConnection._socket">
            <summary>
            The underlying websocket
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.Sockets.SocketConnection.#ctor(Microsoft.Extensions.Logging.ILogger,CryptoExchange.Net.Clients.SocketApiClient,CryptoExchange.Net.Interfaces.IWebsocket,System.String)">
            <summary>
            New socket connection
            </summary>
            <param name="logger">The logger</param>
            <param name="apiClient">The api client</param>
            <param name="socket">The socket</param>
            <param name="tag"></param>
        </member>
        <member name="M:CryptoExchange.Net.Sockets.SocketConnection.HandleOpenAsync">
            <summary>
            Handler for a socket opening
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.Sockets.SocketConnection.HandleCloseAsync">
            <summary>
            Handler for a socket closing without reconnect
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.Sockets.SocketConnection.HandleReconnectingAsync">
            <summary>
            Handler for a socket losing connection and starting reconnect
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.Sockets.SocketConnection.GetReconnectionUrlAsync">
            <summary>
            Get the url to connect to when reconnecting
            </summary>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Sockets.SocketConnection.HandleReconnectedAsync">
            <summary>
            Handler for a socket which has reconnected
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.Sockets.SocketConnection.HandleErrorAsync(System.Exception)">
            <summary>
            Handler for an error on a websocket
            </summary>
            <param name="e">The exception</param>
        </member>
        <member name="M:CryptoExchange.Net.Sockets.SocketConnection.HandleRequestRateLimitedAsync(System.Int32)">
            <summary>
            Handler for whenever a request is rate limited and rate limit behaviour is set to fail
            </summary>
            <param name="requestId"></param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Sockets.SocketConnection.HandleRequestSentAsync(System.Int32)">
            <summary>
            Handler for whenever a request is sent over the websocket
            </summary>
            <param name="requestId">Id of the request sent</param>
        </member>
        <member name="M:CryptoExchange.Net.Sockets.SocketConnection.HandleStreamMessage(System.Net.WebSockets.WebSocketMessageType,System.ReadOnlyMemory{System.Byte})">
            <summary>
            Handle a message
            </summary>
            <param name="data"></param>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Sockets.SocketConnection.ConnectAsync">
            <summary>
            Connect the websocket
            </summary>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Sockets.SocketConnection.GetSocket">
            <summary>
            Retrieve the underlying socket
            </summary>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Sockets.SocketConnection.TriggerReconnectAsync">
            <summary>
            Trigger a reconnect of the socket connection
            </summary>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Sockets.SocketConnection.CloseAsync">
            <summary>
            Close the connection
            </summary>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Sockets.SocketConnection.CloseAsync(CryptoExchange.Net.Sockets.Subscription,System.Boolean)">
            <summary>
            Close a subscription on this connection. If all subscriptions on this connection are closed the connection gets closed as well
            </summary>
            <param name="subscription">Subscription to close</param>
            <param name="unsubEvenIfNotConfirmed">Whether to send an unsub request even if the subscription wasn't confirmed</param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Sockets.SocketConnection.Dispose">
            <summary>
            Dispose the connection
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.Sockets.SocketConnection.CanAddSubscription">
            <summary>
            Whether or not a new subscription can be added to this connection
            </summary>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Sockets.SocketConnection.AddSubscription(CryptoExchange.Net.Sockets.Subscription)">
            <summary>
            Add a subscription to this connection
            </summary>
            <param name="subscription"></param>
        </member>
        <member name="M:CryptoExchange.Net.Sockets.SocketConnection.GetSubscription(System.Int32)">
            <summary>
            Get a subscription on this connection by id
            </summary>
            <param name="id"></param>
        </member>
        <member name="M:CryptoExchange.Net.Sockets.SocketConnection.GetState(System.Boolean)">
            <summary>
            Get the state of the connection
            </summary>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Sockets.SocketConnection.SendAndWaitQueryAsync(CryptoExchange.Net.Sockets.Query,System.Threading.ManualResetEvent)">
            <summary>
            Send a query request and wait for an answer
            </summary>
            <param name="query">Query to send</param>
            <param name="continueEvent">Wait event for when the socket message handler can continue</param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Sockets.SocketConnection.SendAndWaitQueryAsync``1(CryptoExchange.Net.Sockets.Query{``0},System.Threading.ManualResetEvent)">
            <summary>
            Send a query request and wait for an answer
            </summary>
            <typeparam name="T">Query response type</typeparam>
            <param name="query">Query to send</param>
            <param name="continueEvent">Wait event for when the socket message handler can continue</param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Sockets.SocketConnection.Send``1(System.Int32,``0,System.Int32)">
            <summary>
            Send data over the websocket connection
            </summary>
            <typeparam name="T">The type of the object to send</typeparam>
            <param name="requestId">The request id</param>
            <param name="obj">The object to send</param>
            <param name="weight">The weight of the message</param>
        </member>
        <member name="M:CryptoExchange.Net.Sockets.SocketConnection.Send(System.Int32,System.String,System.Int32)">
            <summary>
            Send string data over the websocket connection
            </summary>
            <param name="data">The data to send</param>
            <param name="weight">The weight of the message</param>
            <param name="requestId">The id of the request</param>
        </member>
        <member name="M:CryptoExchange.Net.Sockets.SocketConnection.QueryPeriodic(System.String,System.TimeSpan,System.Func{CryptoExchange.Net.Sockets.SocketConnection,CryptoExchange.Net.Sockets.Query},System.Action{CryptoExchange.Net.Objects.CallResult})">
            <summary>
            Periodically sends data over a socket connection
            </summary>
            <param name="identifier">Identifier for the periodic send</param>
            <param name="interval">How often</param>
            <param name="queryDelegate">Method returning the query to send</param>
            <param name="callback">The callback for processing the response</param>
        </member>
        <member name="T:CryptoExchange.Net.Sockets.SocketConnection.SocketStatus">
            <summary>
            Status of the socket connection
            </summary>
        </member>
        <member name="F:CryptoExchange.Net.Sockets.SocketConnection.SocketStatus.None">
            <summary>
            None/Initial
            </summary>
        </member>
        <member name="F:CryptoExchange.Net.Sockets.SocketConnection.SocketStatus.Connected">
            <summary>
            Connected
            </summary>
        </member>
        <member name="F:CryptoExchange.Net.Sockets.SocketConnection.SocketStatus.Reconnecting">
            <summary>
            Reconnecting
            </summary>
        </member>
        <member name="F:CryptoExchange.Net.Sockets.SocketConnection.SocketStatus.Resubscribing">
            <summary>
            Resubscribing on reconnected socket
            </summary>
        </member>
        <member name="F:CryptoExchange.Net.Sockets.SocketConnection.SocketStatus.Closing">
            <summary>
            Closing
            </summary>
        </member>
        <member name="F:CryptoExchange.Net.Sockets.SocketConnection.SocketStatus.Closed">
            <summary>
            Closed
            </summary>
        </member>
        <member name="F:CryptoExchange.Net.Sockets.SocketConnection.SocketStatus.Disposed">
            <summary>
            Disposed
            </summary>
        </member>
        <member name="T:CryptoExchange.Net.Sockets.Subscription">
            <summary>
            Socket subscription
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Sockets.Subscription.Id">
            <summary>
            Subscription id
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Sockets.Subscription.CanHandleData">
            <summary>
            Can handle data
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Sockets.Subscription.TotalInvocations">
            <summary>
            Total amount of invocations
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Sockets.Subscription.ConnectionInvocations">
            <summary>
            Amount of invocation during this connection
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Sockets.Subscription.UserSubscription">
            <summary>
            Is it a user subscription
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Sockets.Subscription.Confirmed">
            <summary>
            Has the subscription been confirmed
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Sockets.Subscription.HandleUpdatesBeforeConfirmation">
            <summary>
            Whether this subscription should handle update messages before confirmation
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Sockets.Subscription.Closed">
            <summary>
            Is the subscription closed
            </summary>
        </member>
        <member name="F:CryptoExchange.Net.Sockets.Subscription._logger">
            <summary>
            Logger
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Sockets.Subscription.Authenticated">
            <summary>
            If the subscription is a private subscription and needs authentication
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Sockets.Subscription.ListenerIdentifiers">
            <summary>
            Strings to match this subscription to a received message
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Sockets.Subscription.CancellationTokenRegistration">
            <summary>
            Cancellation token registration
            </summary>
        </member>
        <member name="E:CryptoExchange.Net.Sockets.Subscription.Exception">
            <summary>
            Exception event
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.Sockets.Subscription.GetMessageType(CryptoExchange.Net.Interfaces.IMessageAccessor)">
            <summary>
            Get the deserialization type for this message
            </summary>
            <param name="message"></param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Sockets.Subscription.#ctor(Microsoft.Extensions.Logging.ILogger,System.Boolean,System.Boolean)">
            <summary>
            ctor
            </summary>
            <param name="logger"></param>
            <param name="authenticated"></param>
            <param name="userSubscription"></param>
        </member>
        <member name="M:CryptoExchange.Net.Sockets.Subscription.GetSubQuery(CryptoExchange.Net.Sockets.SocketConnection)">
            <summary>
            Get the subscribe query to send when subscribing
            </summary>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Sockets.Subscription.HandleSubQueryResponse(System.Object)">
            <summary>
            Handle a subscription query response
            </summary>
            <param name="message"></param>
        </member>
        <member name="M:CryptoExchange.Net.Sockets.Subscription.HandleUnsubQueryResponse(System.Object)">
            <summary>
            Handle an unsubscription query response
            </summary>
            <param name="message"></param>
        </member>
        <member name="M:CryptoExchange.Net.Sockets.Subscription.GetUnsubQuery">
            <summary>
            Get the unsubscribe query to send when unsubscribing
            </summary>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Sockets.Subscription.Deserialize(CryptoExchange.Net.Interfaces.IMessageAccessor,System.Type)">
            <inheritdoc />
        </member>
        <member name="M:CryptoExchange.Net.Sockets.Subscription.Handle(CryptoExchange.Net.Sockets.SocketConnection,CryptoExchange.Net.Objects.Sockets.DataEvent{System.Object})">
            <summary>
            Handle an update message
            </summary>
            <param name="connection"></param>
            <param name="message"></param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Sockets.Subscription.DoHandleMessage(CryptoExchange.Net.Sockets.SocketConnection,CryptoExchange.Net.Objects.Sockets.DataEvent{System.Object})">
            <summary>
            Handle the update message
            </summary>
            <param name="connection"></param>
            <param name="message"></param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Sockets.Subscription.InvokeExceptionHandler(System.Exception)">
            <summary>
            Invoke the exception event
            </summary>
            <param name="e"></param>
        </member>
        <member name="T:CryptoExchange.Net.Sockets.Subscription.SubscriptionState">
            <summary>
            State of this subscription
            </summary>
            <param name="Id">The id of the subscription</param>
            <param name="Confirmed">True when the subscription query is handled (either accepted or rejected)</param>
            <param name="Invocations">Number of times this subscription got a message</param>
            <param name="Identifiers">Identifiers the subscription is listening to</param>
        </member>
        <member name="M:CryptoExchange.Net.Sockets.Subscription.SubscriptionState.#ctor(System.Int32,System.Boolean,System.Int32,System.Collections.Generic.HashSet{System.String})">
            <summary>
            State of this subscription
            </summary>
            <param name="Id">The id of the subscription</param>
            <param name="Confirmed">True when the subscription query is handled (either accepted or rejected)</param>
            <param name="Invocations">Number of times this subscription got a message</param>
            <param name="Identifiers">Identifiers the subscription is listening to</param>
        </member>
        <member name="P:CryptoExchange.Net.Sockets.Subscription.SubscriptionState.Id">
            <summary>The id of the subscription</summary>
        </member>
        <member name="P:CryptoExchange.Net.Sockets.Subscription.SubscriptionState.Confirmed">
            <summary>True when the subscription query is handled (either accepted or rejected)</summary>
        </member>
        <member name="P:CryptoExchange.Net.Sockets.Subscription.SubscriptionState.Invocations">
            <summary>Number of times this subscription got a message</summary>
        </member>
        <member name="P:CryptoExchange.Net.Sockets.Subscription.SubscriptionState.Identifiers">
            <summary>Identifiers the subscription is listening to</summary>
        </member>
        <member name="M:CryptoExchange.Net.Sockets.Subscription.GetState">
            <summary>
            Get the state of this subscription
            </summary>
            <returns></returns>
        </member>
        <member name="T:CryptoExchange.Net.Sockets.Subscription`2">
            <inheritdoc />
        </member>
        <member name="M:CryptoExchange.Net.Sockets.Subscription`2.#ctor(Microsoft.Extensions.Logging.ILogger,System.Boolean)">
            <summary>
            ctor
            </summary>
            <param name="logger"></param>
            <param name="authenticated"></param>
        </member>
        <member name="M:CryptoExchange.Net.Sockets.Subscription`2.HandleSubQueryResponse(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:CryptoExchange.Net.Sockets.Subscription`2.HandleSubQueryResponse(`0)">
            <summary>
            Handle a subscription query response
            </summary>
            <param name="message"></param>
        </member>
        <member name="M:CryptoExchange.Net.Sockets.Subscription`2.HandleUnsubQueryResponse(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:CryptoExchange.Net.Sockets.Subscription`2.HandleUnsubQueryResponse(`1)">
            <summary>
            Handle an unsubscription query response
            </summary>
            <param name="message"></param>
        </member>
        <member name="T:CryptoExchange.Net.Sockets.SystemSubscription">
            <summary>
            A system subscription
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.Sockets.SystemSubscription.#ctor(Microsoft.Extensions.Logging.ILogger,System.Boolean)">
            <summary>
            ctor
            </summary>
            <param name="logger"></param>
            <param name="authenticated"></param>
        </member>
        <member name="M:CryptoExchange.Net.Sockets.SystemSubscription.GetSubQuery(CryptoExchange.Net.Sockets.SocketConnection)">
            <inheritdoc />
        </member>
        <member name="M:CryptoExchange.Net.Sockets.SystemSubscription.GetUnsubQuery">
            <inheritdoc />
        </member>
        <member name="T:CryptoExchange.Net.Sockets.SystemSubscription`1">
            <inheritdoc />
        </member>
        <member name="M:CryptoExchange.Net.Sockets.SystemSubscription`1.GetMessageType(CryptoExchange.Net.Interfaces.IMessageAccessor)">
            <inheritdoc />
        </member>
        <member name="M:CryptoExchange.Net.Sockets.SystemSubscription`1.DoHandleMessage(CryptoExchange.Net.Sockets.SocketConnection,CryptoExchange.Net.Objects.Sockets.DataEvent{System.Object})">
            <inheritdoc />
        </member>
        <member name="M:CryptoExchange.Net.Sockets.SystemSubscription`1.#ctor(Microsoft.Extensions.Logging.ILogger,System.Boolean)">
            <summary>
            ctor
            </summary>
            <param name="logger"></param>
            <param name="authenticated"></param>
        </member>
        <member name="M:CryptoExchange.Net.Sockets.SystemSubscription`1.HandleMessage(CryptoExchange.Net.Sockets.SocketConnection,CryptoExchange.Net.Objects.Sockets.DataEvent{`0})">
            <summary>
            Handle an update message
            </summary>
            <param name="connection"></param>
            <param name="message"></param>
            <returns></returns>
        </member>
        <member name="T:CryptoExchange.Net.Sockets.WebsocketFactory">
            <summary>
            Default websocket factory implementation
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.Sockets.WebsocketFactory.CreateWebsocket(Microsoft.Extensions.Logging.ILogger,CryptoExchange.Net.Objects.Sockets.WebSocketParameters)">
            <inheritdoc />
        </member>
        <member name="T:CryptoExchange.Net.Testing.Implementations.TestNonceProvider">
            <summary>
            Test implementation for nonce provider, returning a prespecified nonce
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.Testing.Implementations.TestNonceProvider.#ctor(System.Int64)">
            <summary>
            ctor
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.Testing.Implementations.TestNonceProvider.GetNonce">
            <inheritdoc />
        </member>
        <member name="T:CryptoExchange.Net.Testing.RestRequestValidator`1">
            <summary>
            Validator for REST requests, comparing path, http method, authentication and response parsing
            </summary>
            <typeparam name="TClient">The Rest client</typeparam>
        </member>
        <member name="M:CryptoExchange.Net.Testing.RestRequestValidator`1.#ctor(`0,System.String,System.String,System.Func{CryptoExchange.Net.Objects.WebCallResult,System.Boolean},System.String,System.Boolean)">
            <summary>
            ctor
            </summary>
            <param name="client">Client to test</param>
            <param name="folder">Folder for json test values</param>
            <param name="baseAddress">The base address that is expected</param>
            <param name="isAuthenticated">Func for checking if the request is authenticated</param>
            <param name="nestedPropertyForCompare">Property to use for compare</param>
            <param name="stjCompare">Use System.Text.Json for comparing</param>
        </member>
        <member name="M:CryptoExchange.Net.Testing.RestRequestValidator`1.ValidateAsync``1(System.Func{`0,System.Threading.Tasks.Task{CryptoExchange.Net.Objects.WebCallResult{``0}}},System.String,System.String,System.Collections.Generic.List{System.String},System.Boolean,System.Boolean)">
            <summary>
            Validate a request
            </summary>
            <typeparam name="TResponse">Expected response type</typeparam>
            <param name="methodInvoke">Method invocation</param>
            <param name="name">Method name for looking up json test values</param>
            <param name="nestedJsonProperty">Use nested json property for compare</param>
            <param name="ignoreProperties">Ignore certain properties</param>
            <param name="useSingleArrayItem">Use the first item of an json array response</param>
            <param name="skipResponseValidation">Whether to skip the response model validation</param>
            <returns></returns>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="M:CryptoExchange.Net.Testing.RestRequestValidator`1.ValidateAsync``2(System.Func{`0,System.Threading.Tasks.Task{CryptoExchange.Net.Objects.WebCallResult{``0}}},System.String,System.String,System.Collections.Generic.List{System.String},System.Boolean,System.Boolean)">
            <summary>
            Validate a request
            </summary>
            <typeparam name="TResponse">Expected response type</typeparam>
            <typeparam name="TActualResponse">The concrete response type</typeparam>
            <param name="methodInvoke">Method invocation</param>
            <param name="name">Method name for looking up json test values</param>
            <param name="nestedJsonProperty">Use nested json property for compare</param>
            <param name="ignoreProperties">Ignore certain properties</param>
            <param name="useSingleArrayItem">Use the first item of an json array response</param>
            <param name="skipResponseValidation">Whether to skip the response model validation</param>
            <returns></returns>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="M:CryptoExchange.Net.Testing.RestRequestValidator`1.ValidateAsync(System.Func{`0,System.Threading.Tasks.Task{CryptoExchange.Net.Objects.WebCallResult}},System.String)">
            <summary>
            Validate a request
            </summary>
            <param name="methodInvoke">Method invocation</param>
            <param name="name">Method name for looking up json test values</param>
            <returns></returns>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="T:CryptoExchange.Net.Testing.SocketSubscriptionValidator`1">
            <summary>
            Validator for websocket subscriptions, checking expected requests and responses and comparing update models
            </summary>
            <typeparam name="TClient"></typeparam>
        </member>
        <member name="M:CryptoExchange.Net.Testing.SocketSubscriptionValidator`1.#ctor(`0,System.String,System.String,System.String,System.Boolean)">
            <summary>
            ctor
            </summary>
            <param name="client">Client to test</param>
            <param name="folder">Folder for json test values</param>
            <param name="baseAddress">The base address that is expected</param>
            <param name="nestedPropertyForCompare">Property to use for compare</param>
            <param name="stjCompare">Use System.Text.Json for comparing</param>
        </member>
        <member name="M:CryptoExchange.Net.Testing.SocketSubscriptionValidator`1.ValidateAsync``1(System.Func{`0,System.Action{CryptoExchange.Net.Objects.Sockets.DataEvent{``0}},System.Threading.Tasks.Task{CryptoExchange.Net.Objects.CallResult{CryptoExchange.Net.Objects.Sockets.UpdateSubscription}}},System.String,System.String,System.Collections.Generic.List{System.String})">
            <summary>
            Validate a subscription
            </summary>
            <typeparam name="TUpdate">The expected update type</typeparam>
            <param name="methodInvoke">Subscription method invocation</param>
            <param name="name">Method name for looking up json test values</param>
            <param name="nestedJsonProperty">Use nested json property for compare</param>
            <param name="ignoreProperties">Ignore certain properties</param>
            <returns></returns>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="T:CryptoExchange.Net.Testing.TestHelpers">
            <summary>
            Testing helpers
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.Testing.TestHelpers.CheckSignature(CryptoExchange.Net.Clients.RestApiClient,CryptoExchange.Net.Authentication.AuthenticationProvider,System.Net.Http.HttpMethod,System.String,System.Func{System.Collections.Generic.IDictionary{System.String,System.Object},System.Collections.Generic.IDictionary{System.String,System.Object},System.Collections.Generic.IDictionary{System.String,System.String},System.String},System.String,System.Collections.Generic.Dictionary{System.String,System.Object},System.Nullable{System.DateTime},System.Boolean,System.Boolean,System.String)">
            <summary>
            Check a signature matches the expected signature
            </summary>
            <param name="client"></param>
            <param name="authProvider"></param>
            <param name="method"></param>
            <param name="path"></param>
            <param name="getSignature"></param>
            <param name="expectedSignature"></param>
            <param name="parameters"></param>
            <param name="time"></param>
            <param name="disableOrdering"></param>
            <param name="compareCase"></param>
            <param name="host"></param>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="M:CryptoExchange.Net.Testing.TestHelpers.CheckForMissingRestInterfaces``1">
            <summary>
            Scan the TClient rest client type for missing interface methods
            </summary>
            <typeparam name="TClient"></typeparam>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="M:CryptoExchange.Net.Testing.TestHelpers.CheckForMissingSocketInterfaces``1">
            <summary>
            Scan the TClient socket client type for missing interface methods
            </summary>
            <typeparam name="TClient"></typeparam>
            <exception cref="T:System.Exception"></exception>
        </member>
    </members>
</doc>
